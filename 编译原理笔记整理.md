# ⚙️编译原理笔记整理

## 第一章 引论

<img src="./assets/image-20250613145155987.png" alt="image-20250613145155987" style="zoom:50%;" />

### 1. 编译程序

#### 1.1 程序语言技术发展

<img src="./assets/image-20250613000850017.png" alt="image-20250613000850017" style="zoom:50%;" />

#### 1.2 程序的执行方式<font color='red'>（考点）</font>

​	高级语言程序通常采用的执行方式：**<font color='blue'>解释方式</font>**和<font color='blue'>**编译方式**</font>。

**（1）解释程序**

​	**<font color='blue'>边解释边执行</font>**源语言程序<font color='blue'>**（逐个语句地分析和执行）**</font>，不产生目标语言程序。

- **功能：**源程序的一个执行系统
- **工作结果：**源程序的执行结果
- **实现技术上：**执行中间代码
- **😎优点：**
  - 易于查错 启动速度快
  - 内存使用少
  - 跨平台 移植性好
- **😢缺点：**
  - 效率低，运行速度慢

<img src="./assets/image-20250613003546314.png" alt="image-20250613003546314" style="zoom:67%;" />

**（2）编译程序**

​	能够把某种语言的程序**<font color='blue'>转换成另一种语言的程序</font>**，而后者与前者**<font color='blue'>在逻辑上是等价的</font>**。对整个程序进行分析翻译成等价机器语言程序后执行。

==🌟编译就是全文翻译，全部翻译完才执行。==

- **功能：**源程序的一个转换系统
- **工作结果：**源程序的目标代码
- **实现技术上：**把中间代码转成目标程序
- **😎优点：**
  - 执行效率高
- **😢缺点：**
  - 在运行中发现的错误必须查找整个程序确定
  - 移植性不好

<img src="./assets/image-20250613003633546.png" alt="image-20250613003633546" style="zoom: 67%;" />

### 2. 编译过程

​	词法分析、语法分析、语义分析中间代码生成、优化、目标代码生成

#### 2.1 词法分析

<img src="./assets/image-20250613005938523.png" alt="image-20250613005938523" style="zoom:67%;" />

​	源程序➡️token序列

#### 2.2 语法分析

<img src="./assets/image-20250613010034252.png" alt="image-20250613010034252" style="zoom:67%;" />

​	token序列➡️语法树

#### 2.3 语义分析与中间代码

​	语法树➡️中间代码

##### 2.3.1 语义分析

<img src="./assets/image-20250613010809715.png" alt="image-20250613010809715" style="zoom:67%;" />

##### 2.3.3 中间代码生成

<img src="./assets/image-20250613010900681.png" alt="image-20250613010900681" style="zoom:67%;" />

<img src="./assets/image-20250613010948535.png" alt="image-20250613010948535" style="zoom:67%;" />

##### 2.3.4 优化

​	中间代码➡️功能相同，功效更高的优化后的中间表示代码

<img src="./assets/image-20250613011150651.png" alt="image-20250613011150651" style="zoom:67%;" />

##### 2.3.5 目标代码生成

​	中间代码/优化后的中间表示代码➡️特定机器上的低级语言代码

<img src="./assets/image-20250613011256645.png" alt="image-20250613011256645" style="zoom:67%;" />

### 3. 编译程序的结构

<img src="./assets/image-20250613011537353.png" alt="image-20250613011537353" style="zoom:67%;" />

<img src="./assets/image-20250613015059737.png" alt="image-20250613015059737" style="zoom:55%;" />

#### 3.1 符号表

<img src="./assets/image-20250613012213179.png" alt="image-20250613012213179" style="zoom:67%;" />

#### 3.2 出错处理

​	程序中的错误类型：<font color='blue'>**语法错误**</font>、<font color='blue'>**语义错误**</font>

##### 3.2.1 语法错误

<img src="./assets/image-20250613014015769.png" alt="image-20250613014015769" style="zoom:55%;" />

##### 3.2.2 语义错误

<img src="./assets/image-20250613014845807.png" alt="image-20250613014845807" style="zoom: 40%;" />

#### 3.3 编译阶段的组合

​	编译程序可以从逻辑上分成几个阶段，<font color='blue'>**对于各个阶段的划分仅仅是指其逻辑结构**</font>，而在具体实现时，经常是将几个阶段组合在一起。例如，可以将各部分组合成前端和后端。

<img src="./assets/image-20250613015259201.png" alt="image-20250613015259201" style="zoom:67%;" />

#### 3.4 并发程序

<img src="./assets/image-20250613015403456.png" alt="image-20250613015403456" style="zoom:55%;" />

<img src="./assets/image-20250613015421492.png" alt="image-20250613015421492" style="zoom:67%;" />

#### 3.5 形式化验证

- 由于大量的不确定交织的存在，并发程序的性质验证存在更大的挑战。
- 形式化验证能够**<font color='blue'>模拟并发程序所有可能的执行，考虑任意线程交错</font>**，这一现象在程序测试和定理证明中都很难捕捉到。
- 对程序员编写的代码，即由高级编程语言构成的代码，进行自动的形式验证，保证其正确性、安全性等是极其重要的。
- 自动化工具能够直接对高级编程语言进行模型检测，而无需模型检查中通常需要的专业工作是期望的。

##### 3.5.1 遍<font color='red'>（考点）</font>

- **定义：**对==**源程序**==或==**源程序的中间结果**==<font color='blue'>**从头到尾扫描一次，并做相关处理，生成新的中间结果或目标程序**</font>的过程。

- “遍”是<font color='blue'>**处理数据的一个完整周期**</font>，每遍工作从外存上获得<font color='blue'>**前一遍的中间结果（源程序）**</font>，完成它所含的有关工作之后，再把结果记录于外存。

<img src="./assets/image-20250613015729857.png" alt="image-20250613015729857" style="zoom:45%;" />

- **遍的次数和效果**

​	一个编译程序可由一遍、两遍或多遍完成。==每一遍可完成不同的阶段或多个阶段的工作。==

<img src="./assets/image-20250613020006819.png" alt="image-20250613020006819" style="zoom:50%;" />

​	**一遍扫描：**对源程序或源程序的中间结果从头到尾扫描**一次**，生成目标代码

​		**😎好处：**避免重复性工作，编译速度快。

​		**😢缺点：**发生语法或语义错误时，前面所作的工作可能要半途而废。不便于分工，不便于优化，算法不清晰。

​	**多遍扫描：**对源程序或源程序的中间结果从头到尾扫描**多次**，生成目标代码

​		**😎好处：**节省内存空间，提高目标代码质量，使编译的逻辑结构清晰，算法清晰。

​		**😢缺点：**编译时间较长。

==**🌟注意区分：**==“遍”和“阶段”物理上&逻辑上

==📑**判断题：**==一遍扫描的编译程序对源程序扫描一遍，多遍扫描的编译程序对**源程序**扫描多遍（**<font color='red'>X</font>**）

### 4. 编译程序的生成

#### 4.1 编译程序实现语言

<img src="./assets/image-20250613143659630.png" alt="image-20250613143659630" style="zoom:67%;" />

#### 4.2 T形图<font color='red'>（考点）</font>

<img src="./assets/image-20250613143729964.png" alt="image-20250613143729964" style="zoom:67%;" />

<img src="./assets/image-20250613143755616.png" alt="image-20250613143755616" style="zoom:67%;" />

#### 4.3 编译程序的生成技术

自编译、交叉编译、自展、移植

##### 4.3.1 自编译

<img src="./assets/image-20250613144014528.png" alt="image-20250613144014528" style="zoom:67%;" />

##### 4.3.2 交叉编译

<img src="./assets/image-20250613144435894.png" alt="image-20250613144435894" style="zoom:67%;" />

##### 4.3.3 自展

L0->L1->L2->...->Ln（目标语言程序）

<img src="./assets/image-20250613144801228.png" alt="image-20250613144801228" style="zoom:60%;" />

##### 4.3.4 移植

<img src="./assets/image-20250613144832900.png" alt="image-20250613144832900" style="zoom:60%;" />

#### 4.4 自动编译

<img src="./assets/image-20250613145011433.png" alt="image-20250613145011433" style="zoom:60%;" />

#### 4.5 编译程序的分类

- 诊断型编译程序
- 优化型编译程序
- 交叉型编译程序
- 可变目标型编译程序



## 第二章 高级语言及其语法描述

### 2.1 程序设计语言的定义

<img src="./assets/image-20250613145602947.png" alt="image-20250613145602947" style="zoom:67%;" />

#### 2.1.1 内涵

<img src="./assets/image-20250613145913940.png" alt="image-20250613145913940" style="zoom: 50%;" />

##### 2.1.1.1 语法

<img src="./assets/image-20250613150104522.png" alt="image-20250613150104522" style="zoom:67%;" />

**1、语法描述方式**

<img src="./assets/image-20250613150139918.png" alt="image-20250613150139918" style="zoom:67%;" />

<img src="./assets/image-20250613150151845.png" alt="image-20250613150151845" style="zoom:67%;" />

<img src="./assets/image-20250613150211649.png" alt="image-20250613150211649" style="zoom:67%;" />

<img src="./assets/image-20250613150246907.png" alt="image-20250613150246907" style="zoom:67%;" />

##### 2.1.1.2 语义

- **语义问题：**语言的单词符号和语法单位的意义
- **语义：**一组规则，使用它可以定义一个程序的意义
- **采用的方法：**基于属性文法的语法制导翻译方法

#### 2.1.2 功能

<img src="./assets/image-20250613150522940.png" alt="image-20250613150522940" style="zoom:67%;" />

### 2.2 高级语言的一般特性

#### 2.2.1 程序结构

##### 2.2.1.1 单层结构

<img src="./assets/image-20250613150633024.png" alt="image-20250613150633024" style="zoom:67%;" />

##### 2.2.1.2 多层结构

<img src="./assets/image-20250613150656728.png" alt="image-20250613150656728" style="zoom:67%;" />

#### 2.2.2 数据类型与操作

##### 2.2.2.1 初等类型、复合类型、抽象数据类型

<img src="./assets/image-20250613150759838.png" alt="image-20250613150759838" style="zoom:67%;" />

##### 2.2.2.2 类型

**定义：**==一个值的集合和定义在这个值集上的一组操作的总称==

- 每个被计算对象都带有自己的类型，以类型作为值的属性的概括
- 不同类型的值具有不同的操作运算

**e.g.** C语言中的整型变量(int)，其值集为某个区间上的整数，定义在其上的操作为+, -, \*, /等

##### 2.2.2.3 抽象数据类型

<img src="./assets/image-20250613151412974.png" alt="image-20250613151412974" style="zoom:67%;" />

<img src="./assets/image-20250613151538953.png" alt="image-20250613151538953" style="zoom: 50%;" />

**😎优点：**

<img src="./assets/image-20250613151622185.png" alt="image-20250613151622185" style="zoom: 50%;" />

#### 2.2.3 语句与控制结构

<img src="./assets/image-20250613151743963.png" alt="image-20250613151743963" style="zoom:50%;" />

##### 2.2.3.1 表达式

<img src="./assets/image-20250613151842020.png" alt="image-20250613151842020" style="zoom:50%;" />

##### 2.2.3.2 语句

<img src="./assets/image-20250613151950868.png" alt="image-20250613151950868" style="zoom:50%;" />

**（1）赋值语句**

<img src="./assets/image-20250613152014898.png" alt="image-20250613152014898" style="zoom:50%;" />

**（2）控制语句**

<img src="./assets/image-20250613152145528.png" alt="image-20250613152145528" style="zoom:50%;" />

**（3）说明语句**

<img src="./assets/image-20250613152211112.png" alt="image-20250613152211112" style="zoom:50%;" />

### 2.3 程序语言的语法描述

编译原理=形式语言理论+编译技术

#### 2.3.1 形式语言

**1、定义：**

- 通过人们公认的符号、表达方式所描述的一种语言
- 是某个<font color='blue'>**字母表上的字符串的集合**</font>，有一定的描述范围

**2、基本概念**

<img src="./assets/image-20250613152453428.png" alt="image-20250613152453428" style="zoom:50%;" />

<img src="./assets/image-20250613152509227.png" alt="image-20250613152509227" style="zoom:50%;" />

<img src="./assets/image-20250613152516858.png" alt="image-20250613152516858" style="zoom:50%;" />

<img src="./assets/image-20250613152527800.png" alt="image-20250613152527800" style="zoom:50%;" />

<img src="./assets/image-20250613152535765.png" alt="image-20250613152535765" style="zoom:50%;" />

<img src="./assets/image-20250613152601204.png" alt="image-20250613152601204" style="zoom:50%;" />

<img src="./assets/image-20250613152615088.png" alt="image-20250613152615088" style="zoom:50%;" />

###### 🌟**闭包**<font color='red'>**（考点）**</font>

<img src="./assets/image-20250613152731991.png" alt="image-20250613152731991" style="zoom:50%;" />

#### 2.3.2 文法

<img src="./assets/image-20250613152835436.png" alt="image-20250613152835436" style="zoom:50%;" />

**1、Chomsky文法**

<img src="./assets/image-20250613153028408.png" alt="image-20250613153028408" style="zoom:50%;" />

<img src="./assets/image-20250613154637031.png" alt="image-20250613154637031" style="zoom:67%;" />

<img src="./assets/image-20250613154955533.png" alt="image-20250613154955533" style="zoom:67%;" />

<img src="./assets/image-20250613155006616.png" alt="image-20250613155006616" style="zoom:67%;" />

<img src="./assets/image-20250613160553812.png" alt="image-20250613160553812" style="zoom:67%;" />

**（1）3型文法（正规文法）**

<img src="./assets/image-20250613154722809.png" alt="image-20250613154722809" style="zoom:67%;" />

**（2）2型文法（上下文无关文法）**

​	上下文无关文法有足够能力描述现在多数程序设计语言的语法结构

<img src="./assets/image-20250613154803800.png" alt="image-20250613154803800" style="zoom: 67%;" />

<img src="./assets/image-20250613154818633.png" alt="image-20250613154818633" style="zoom:67%;" />

**==🌟上下文无关文法描述语言语法结构==**

<img src="./assets/image-20250613160432591.png" alt="image-20250613160432591" style="zoom:67%;" />

**==😢非CFL结构==**

<img src="./assets/image-20250613160712289.png" alt="image-20250613160712289" style="zoom:67%;" />

<img src="./assets/image-20250613160729673.png" alt="image-20250613160729673" style="zoom:67%;" />

**（3）1型文法（上下文有关文法）**

自然语言是上下文有关的

<img src="./assets/image-20250613154847437.png" alt="image-20250613154847437" style="zoom:67%;" />

<img src="./assets/image-20250613154913306.png" alt="image-20250613154913306" style="zoom:67%;" />

**（4）0型文法（无限制文法，短语文法）**

<img src="./assets/image-20250613154943825.png" alt="image-20250613154943825" style="zoom:67%;" />

**2、形式定义**

<img src="./assets/image-20250613153019501.png" alt="image-20250613153019501" style="zoom:50%;" />

<img src="./assets/image-20250613153151622.png" alt="image-20250613153151622" style="zoom:50%;" />

<img src="./assets/image-20250613153202726.png" alt="image-20250613153202726" style="zoom:50%;" />

<img src="./assets/image-20250613153301227.png" alt="image-20250613153301227" style="zoom:50%;" />

**3、直接推导与归约**

<img src="./assets/image-20250613153523736.png" alt="image-20250613153523736" style="zoom: 50%;" />

**4、推导**

<img src="./assets/image-20250613153552999.png" alt="image-20250613153552999" style="zoom: 50%;" />

**5、最左（右）推导（归约）**<font color='red'>**（考点）**</font>

<img src="./assets/image-20250613153653576.png" alt="image-20250613153653576" style="zoom: 50%;" />

<img src="./assets/image-20250613153709659.png" alt="image-20250613153709659" style="zoom:50%;" />

**6、句型、句子、语言**

<img src="./assets/image-20250613154118783.png" alt="image-20250613154118783" style="zoom:50%;" />

<img src="./assets/image-20250613154134557.png" alt="image-20250613154134557" style="zoom:50%;" />

<img src="./assets/image-20250613154155543.png" alt="image-20250613154155543" style="zoom:50%;" />

<img src="./assets/image-20250613154207126.png" alt="image-20250613154207126" style="zoom:50%;" />

<img src="./assets/image-20250613154224133.png" alt="image-20250613154224133" style="zoom:50%;" />

<img src="./assets/image-20250613154512058.png" alt="image-20250613154512058" style="zoom:50%;" />

==**要求开头元素非0：**==

<img src="./assets/image-20250613154453618.png" alt="image-20250613154453618" style="zoom:50%;" />

**7、语法分析树和文法的二义性<font color='red'>（考点）</font>**

**（1）语法树**

<img src="./assets/image-20250613160809737.png" alt="image-20250613160809737" style="zoom: 50%;" />

<img src="./assets/image-20250613160905052.png" alt="image-20250613160905052" style="zoom: 50%;" />

==**🌟注意：**==

<img src="./assets/image-20250613161058571.png" alt="image-20250613161058571" style="zoom:50%;" />

<img src="./assets/image-20250613161239957.png" alt="image-20250613161239957" style="zoom:50%;" />

<img src="./assets/image-20250613161253068.png" alt="image-20250613161253068" style="zoom:50%;" />

###### **（2）二义性<font color='red'>（考点）</font>**

**定义（同时也是证明二义性的方法）：**

<img src="./assets/image-20250613161500470.png" alt="image-20250613161500470" style="zoom:50%;" />

<img src="./assets/image-20250613161606600-1749802726401-1.png" alt="image-20250613161606600" style="zoom:50%;" />

<img src="./assets/image-20250613161922093.png" alt="image-20250613161922093" style="zoom:50%;" />

**==📑判断题：==**

- 一个文法为二义的，则这个文法的每一个句子都对应两个不同的语法树（X）
- 对于二义文法G，其生成的语言L（G）必定是二义的（X）

==😯**无二义文法：**==LL（1）文法、LR（0）文法、SLR（1）文法、LR（1）文法

==**🤔消除二义性的方法：**==

<img src="./assets/image-20250613162005488.png" alt="image-20250613162005488" style="zoom:50%;" />

​	**STEP1** 划分优先级与结合性

​	**STEP2** 引入新的$V_N$+子结构+优先级

​	**STEP3** 递归$V_N$在$V_T$左边（左结合）

## 第三章 词法分析

<img src="./assets/image-20250613224108533.png" alt="image-20250613224108533" style="zoom:50%;" />

### 3.1 对于词法分析器的要求

#### 3.1.1 功能

<img src="./assets/image-20250613180046487.png" alt="image-20250613180046487" style="zoom:50%;" />

**1、单词符号表示形式**

<img src="./assets/image-20250613180219458.png" alt="image-20250613180219458" style="zoom:50%;" />

**2、分类方法**

<img src="./assets/image-20250613180251588.png" alt="image-20250613180251588" style="zoom:50%;" />

**3、单词符号的属性**

<img src="./assets/image-20250613180456037.png" alt="image-20250613180456037" style="zoom:50%;" />

**4、词法分析示例**

<img src="./assets/image-20250613180525651.png" alt="image-20250613180525651" style="zoom:50%;" />

<img src="./assets/image-20250613180538447.png" alt="image-20250613180538447" style="zoom:50%;" />

**5、实现方式**

<img src="./assets/image-20250613180634012.png" alt="image-20250613180634012" style="zoom:50%;" />

### 3.2 词法分析器的设计

**1、结构**

<img src="./assets/image-20250613180727332.png" alt="image-20250613180727332" style="zoom:67%;" />

**2、超前搜索**

<img src="./assets/image-20250613220855078.png" alt="image-20250613220855078" style="zoom:50%;" />

<img src="./assets/image-20250613180911044.png" alt="image-20250613180911044" style="zoom:50%;" />

**3、状态转换图**

<img src="./assets/image-20250613220939663.png" alt="image-20250613220939663" style="zoom:50%;" />

<img src="./assets/image-20250613221249134.png" alt="image-20250613221249134" style="zoom:50%;" />

<img src="./assets/image-20250613221322116.png" alt="image-20250613221322116" style="zoom:50%;" />

<img src="./assets/image-20250613221422801.png" alt="image-20250613221422801" style="zoom:50%;" />

### 3.3 正规表达式与有限自动机

<img src="./assets/image-20250613221440870.png" alt="image-20250613221440870" style="zoom:50%;" />

#### 3.3.1 正规式与正规集

<img src="./assets/image-20250613221951378.png" alt="image-20250613221951378" style="zoom:50%;" />

| 正规式 |  正规集   |
| :----: | :-------: |
| (U\|V) | L(U)∪L(V) |
| (U·V)  | L(U)L(V)  |
|  (U)*  |  (L(U))*  |

#### 3.3.2 从正规式构造等价的NFA（Thompson算法）

<img src="./assets/image-20250613222234527.png" alt="image-20250613222234527" style="zoom:50%;" />

<img src="./assets/image-20250613222328552.png" alt="image-20250613222328552" style="zoom:50%;" />

<img src="./assets/image-20250613222336219.png" alt="image-20250613222336219" style="zoom:50%;" />

<img src="./assets/image-20250613222418703.png" alt="image-20250613222418703" style="zoom:50%;" />

#### 3.3.3 从正规文法构造等价的NFA

**1、左线性正规文法**

<img src="./assets/image-20250624163814466.png" alt="image-20250624163814466" style="zoom:50%;" />

**2、右线性正规文法**

<img src="./assets/image-20250624163829253.png" alt="image-20250624163829253" style="zoom:50%;" />

<img src="./assets/image-20250624163843470.png" alt="image-20250624163843470" style="zoom:50%;" />

#### 3.3.4 确定有限自动机（DFA）

<img src="./assets/image-20250613222457617.png" alt="image-20250613222457617" style="zoom:50%;" />

<img src="./assets/image-20250613222512086.png" alt="image-20250613222512086" style="zoom:50%;" />

**==🤔DFA VS NFA==**

|              | DFA                                                | NFA                                                          |
| ------------ | -------------------------------------------------- | ------------------------------------------------------------ |
| **初态**     | 仅有一个                                           | 可有多个                                                     |
| **输入字母** | 每一个状态对于字母表中的每一个符号都有一个转移函数 | 一个状态对于字母表中的每一个符号可能不存在转移函数或者存在空转换 |
| **转移状态** | 下一状态是确定的，即唯一的                         | 下一状态是不确定的，可能存在多个转移状态                     |

<img src="./assets/image-20250613222827756.png" alt="image-20250613222827756" style="zoom: 50%;" />

==**😯DFA与NFA等价**==

<img src="./assets/image-20250613222927244.png" alt="image-20250613222927244" style="zoom:50%;" />

<img src="./assets/image-20250613222941019.png" alt="image-20250613222941019" style="zoom:50%;" />

###### **==😎NFA转DFA<font color='red'>（考点）</font>==**

<img src="./assets/image-20250613223156488.png" alt="image-20250613223156488" style="zoom:50%;" />

<img src="./assets/image-20250613223229969.png" alt="image-20250613223229969" style="zoom:50%;" />

<img src="./assets/image-20250613223321443.png" alt="image-20250613223321443" style="zoom:50%;" />

###### **==😎DFA的化简<font color='red'>（考点）</font>==**

<img src="./assets/image-20250613223411120.png" alt="image-20250613223411120" style="zoom:50%;" />

==<font color='red'>**📑步骤：**</font>==

<img src="./assets/image-20250613223525769.png" alt="image-20250613223525769" style="zoom:50%;" />

<img src="./assets/image-20250613223604180.png" alt="image-20250613223604180" style="zoom:50%;" />

<img src="./assets/image-20250613223616949.png" alt="image-20250613223616949" style="zoom:50%;" />

**==📇考试题：==**

为正规式(a|b)\*ab 构造等价的确定型有限自动机并最小化

### 3.4 词法分析器的自动生成

#### 3.4.1 LEX

<img src="./assets/image-20250613223830364.png" alt="image-20250613223830364" style="zoom:50%;" />

<img src="./assets/image-20250613223944559.png" alt="image-20250613223944559" style="zoom:50%;" />

<img src="./assets/image-20250613224049456.png" alt="image-20250613224049456" style="zoom:50%;" />

## 第四章 语法分析——自上而下分析

### 4.1 语法分析器的功能

<img src="./assets/image-20250614001422773.png" alt="image-20250614001422773" style="zoom:50%;" />

#### 4.1.1 语法分析方法

**1、自上而下分析**

从**<font color='blue'>文法的开始符号</font>**出发，反复使用各种产生式，寻找与输入符号匹配的**<font color='blue'>最左推导</font>**。

构建语法树、下推自动机、LL（K）分析法

**2、自下而上分析**

从**<font color='blue'>输入符号串</font>**开始，逐步进行归约（**<font color='blue'>最右推导</font>**的逆过程），直至归约到文法的开始符号。

移进-规约方法、CYK算法、early算法、算符优先分析法、LR分析法

### 4.2 自上而下分析方法概述

#### 4.2.1 自上而下分析

从**<font color='blue'>文法的开始符号</font>**出发，向下推导，推出句子

自上而下地为输入串建立一棵语法树，即为输入串寻找一个**<font color='blue'>最左推导</font>**

**基本思想：**最左推导过程中，为当前字符选择一个产生式，根据**<font color='blue'>产生式右部首字符</font>**进行匹配

<img src="./assets/image-20250614002136473.png" alt="image-20250614002136473" style="zoom:50%;" />

<img src="./assets/image-20250614002208066.png" alt="image-20250614002208066" style="zoom:50%;" />

#### 4.2.2 带回溯自上而下分析面临的问题

<img src="./assets/image-20250614002731916.png" alt="image-20250614002731916" style="zoom:50%;" />

### 4.3 LL（1）分析方法<font color='red'>（考点）</font>

<img src="./assets/image-20250614010034651.png" alt="image-20250614010034651" style="zoom:50%;" />

#### 4.3.1 左递归文法

<img src="./assets/image-20250614010054937.png" alt="image-20250614010054937" style="zoom:50%;" />

<img src="./assets/image-20250614010233161.png" alt="image-20250614010233161" style="zoom:50%;" />

#### 4.3.2 消除直接左递归

##### 4.3.2.1 消除左递归的方法

**1、P → Pα│β（α≠ε，β不以P开头）**

➡️P → βP'

​     P' → αP' │ε

**2、P→Pα1│Pα2 │… │Pαm │β1 │β2 │… │βn（αi≠ε，βi不以P开头）**

➡️P→ β1 P' │β2 P' │...│βn P'  

​     P' →α1 P' │ α2 P' │… │αm P' │ε

##### 4.3.2.2 识别与消除左递归的方法

<img src="./assets/image-20250614011315420.png" alt="image-20250614011315420" style="zoom:50%;" />

<img src="./assets/image-20250614012209896.png" alt="image-20250614012209896" style="zoom:50%;" />

<img src="./assets/image-20250614013329245.png" alt="image-20250614013329245" style="zoom:50%;" />

消除完左递归，需要提取公共左因子

<img src="./assets/image-20250624204010127.png" alt="image-20250624204010127" style="zoom:50%;" />

##### 4.3.2.3 回溯

**1、问题**

<img src="./assets/image-20250614014015585.png" alt="image-20250614014015585" style="zoom:50%;" />

<img src="./assets/image-20250614014031616.png" alt="image-20250614014031616" style="zoom:50%;" />

**2、原因**

<img src="./assets/image-20250614014056139.png" alt="image-20250614014056139" style="zoom:50%;" />

##### 4.3.2.4 文法要求

<img src="./assets/image-20250614014920151.png" alt="image-20250614014920151" style="zoom:50%;" />

==**🤔对于第三条的解释：**==

<img src="./assets/image-20250614020100436.png" alt="image-20250614020100436" style="zoom:50%;" />

<img src="./assets/image-20250614015931688.png" alt="image-20250614015931688" style="zoom:50%;" />

<img src="./assets/image-20250614020010579.png" alt="image-20250614020010579" style="zoom:50%;" />

##### 4.3.2.5 LL(1)分析方法

<img src="./assets/image-20250614015737311.png" alt="image-20250614015737311" style="zoom:50%;" />

##### 4.3.2.6 FIRST构造

**1、FIRST(α)构造（α为符号串）**

<img src="./assets/image-20250614020303380.png" alt="image-20250614020303380" style="zoom:50%;" />

<img src="./assets/image-20250614021036155.png" alt="image-20250614021036155" style="zoom:50%;" />

**2、FIRST(X)构造（X包含了终结符和非终结符）**

<img src="./assets/image-20250614020827899.png" alt="image-20250614020827899" style="zoom:50%;" />

<img src="./assets/image-20250614020928715.png" alt="image-20250614020928715" style="zoom:50%;" />

##### 4.3.2.7 FOLLOW构造

**1、FOLLOW(A)构造（A为非终结符）**

<img src="./assets/image-20250614021435943.png" alt="image-20250614021435943" style="zoom:50%;" />

<img src="./assets/image-20250614021637773.png" alt="image-20250614021637773" style="zoom:50%;" />

### 4.4 递归下降分析程序<font color='red'>（考点）</font>

<img src="./assets/image-20250614021747659.png" alt="image-20250614021747659" style="zoom:50%;" />

<img src="./assets/image-20250614021838662.png" alt="image-20250614021838662" style="zoom:50%;" />

<img src="./assets/image-20250614021854174.png" alt="image-20250614021854174" style="zoom:50%;" />

==**📑这一板块的考点：**在根据文法得到FIRST和FOLLOW集合后，构造每一个产生式的程序==

<img src="./assets/image-20250614022233245.png" alt="image-20250614022233245" style="zoom: 67%;" />

### 4.5 预测分析程序

<img src="./assets/image-20250614022409964.png" alt="image-20250614022409964" style="zoom: 67%;" />

<img src="./assets/image-20250614022435669.png" alt="image-20250614022435669" style="zoom:50%;" />

#### 4.5.1 LL(1)分析表

<img src="./assets/image-20250614022624041.png" alt="image-20250614022624041" style="zoom:50%;" />

<img src="./assets/image-20250614022641375.png" alt="image-20250614022641375" style="zoom:50%;" />

<img src="./assets/image-20250614023808523.png" alt="image-20250614023808523" style="zoom:50%;" />

<img src="./assets/image-20250614024007033.png" alt="image-20250614024007033" style="zoom:50%;" />

#### 4.5.2 栈

<img src="./assets/image-20250614024118077.png" alt="image-20250614024118077" style="zoom:50%;" />

#### 4.5.3 总控程序

<img src="./assets/image-20250614024217232.png" alt="image-20250614024217232" style="zoom:50%;" />

<img src="./assets/image-20250614024257876.png" alt="image-20250614024257876" style="zoom:50%;" />

<img src="./assets/image-20250614024311529.png" alt="image-20250614024311529" style="zoom:50%;" />

<img src="./assets/image-20250614024400317.png" alt="image-20250614024400317" style="zoom:50%;" />

<img src="./assets/image-20250614024513496.png" alt="image-20250614024513496" style="zoom:50%;" />



## 第五章 语法分析——自下而上分析

<img src="./assets/image-20250615171824341.png" alt="image-20250615171824341" style="zoom: 50%;" />

### 5.1 自下而上分析基本问题

==**🌟两大问题 **==

- 如何找出或确定**<font color='blue'>可规约串</font>**？
- 对找出的可规约串**<font color='blue'>替换为哪一个非终结符号</font>**？

#### 5.1.1 归约

**1、移进-归约法**

<img src="./assets/image-20250615172142034.png" alt="image-20250615172142034" style="zoom: 50%;" /><img src="./assets/image-20250615172241733.png" alt="image-20250615172241733" style="zoom: 50%;" />

**（1）符号栈的使用**

<img src="./assets/image-20250615172351392.png" alt="image-20250615172351392" style="zoom: 50%;" />

<img src="./assets/image-20250615172410515.png" alt="image-20250615172410515" style="zoom: 50%;" />

**（2）语法分析的操作**

<img src="./assets/image-20250615172606488.png" alt="image-20250615172606488" style="zoom:50%;" />

**（3）语法树的表示——穿线表**

<img src="./assets/image-20250615172953734.png" alt="image-20250615172953734" style="zoom:50%;" />

<img src="./assets/image-20250615173040827.png" alt="image-20250615173040827" style="zoom:50%;" />

### 5.2 算符优先分析方法<font color='red'>（考点）</font>

#### 5.2.1 定义

**1、分析步骤**

**STEP1** 定义<font color='blue'>**终结符**</font>（算符）的优先关系

**STEP2** 按终结符（算符）的优先关系控制自下而上语法分析过程（寻找**<font color='blue'>“可归约串”</font>**和进行归约）。

**2、特点**

**<font color='blue'>分析速度快</font>**，适于**<font color='blue'>表达式</font>**的语法分析。

#### 5.2.2 优先关系

<img src="./assets/image-20250615173808790.png" alt="image-20250615173808790" style="zoom:50%;" />

**==😯a<·b不等价于b·>a==** 

#### 5.2.3 算符文法

##### **5.2.3.1 定义**

<img src="./assets/image-20250615174039394.png" alt="image-20250615174039394" style="zoom:50%;" />

##### **5.2.3.2 算符优先关系**

<img src="./assets/image-20250615174302688.png" alt="image-20250615174302688" style="zoom:50%;" />

==**🤔对于可能会紧挨着的或者当中隔了一个非终结符的两个终结符，需要更多步才能推导出来的哪个优先级更高**==

==**🌟并非所有的优先关系表都存在优先函数**==

==**🌟一旦存在优先函数，优先函数就不唯一（无穷多）**==

##### **5.2.3.3 算符优先文法**

<img src="./assets/image-20250615174652518.png" alt="image-20250615174652518" style="zoom:50%;" />

<img src="./assets/image-20250615180210276.png" alt="image-20250615180210276" style="zoom:50%;" />

<img src="./assets/image-20250615180226757.png" alt="image-20250615180226757" style="zoom:50%;" />

##### **5.2.3.4 优先关系表的构造**

<img src="./assets/image-20250615180341668.png" alt="image-20250615180341668" style="zoom:50%;" />

**（1）FIRSTVT(P)和LASTVT(P)**

<img src="./assets/image-20250615180629263.png" alt="image-20250615180629263" style="zoom:50%;" />

==**🤔FIRSTVT(P)：**产生式左侧为P时，右边的式子中**<font color='blue'>第一个终结符</font>**==

==**🤔LASTVT(P)：**产生式左侧为P时，右边的式子中**<font color='blue'>最后一个终结符</font>**==

<img src="./assets/image-20250615180859044.png" alt="image-20250615180859044" style="zoom:50%;" />

**==😎构造方法==**

**最终成果：**二维布尔矩阵

<img src="./assets/image-20250615184326977.png" alt="image-20250615184326977" style="zoom:50%;" />

==**📑以FIRSTVT(P)为例：**==

<font color='blue'>**对于规则1（若 P → a … 或 P → Qa … , 则 a ∈FIRSTVT(P)）**</font>

把所有初值为真的数组元素 F[P, a] 的符号对 (P, a) 全都放在STACK之中。

**<font color='blue'>对于规则2（若 a ∈FIRSTVT(Q) , 且 P → Q … , 则 a ∈FIRSTVT(P)）</font>**

如果栈STACK不空，就将栈顶逐出，记此项为(Q, a)。对于每个形如**<font color='blue'>P→Q…</font>**的产生式，若F[P, a]为假，则变其值为真，且将(P, a)推进STACK栈。

上述过程必须一直重复，直至栈STACK拆空为止。

<img src="./assets/image-20250615191036619.png" alt="image-20250615191036619" style="zoom:50%;" />

<img src="./assets/image-20250615191024787.png" alt="image-20250615191024787" style="zoom: 33%;" />

**（2）优先关系表的构造**

<img src="./assets/image-20250615191220781.png" alt="image-20250615191220781" style="zoom: 33%;" />

==**😎构造算法：**==遍历每一个产生式右边长度大于1的式子

<img src="./assets/image-20250615191235644.png" alt="image-20250615191235644" style="zoom: 33%;" />

<img src="./assets/image-20250615191929479.png" alt="image-20250615191929479" style="zoom: 33%;" />

##### **5.2.3.5 短语**

<img src="./assets/image-20250615192021305.png" alt="image-20250615192021305" style="zoom: 33%;" />

<img src="./assets/image-20250615192038601.png" alt="image-20250615192038601" style="zoom: 33%;" />

<img src="./assets/image-20250615192052518.png" alt="image-20250615192052518" style="zoom: 33%;" />

##### **5.2.3.6 最左素短语**

<img src="./assets/image-20250615192136547.png" alt="image-20250615192136547" style="zoom: 33%;" />

<img src="./assets/image-20250615192152727.png" alt="image-20250615192152727" style="zoom: 33%;" />

<img src="./assets/image-20250615192203646.png" alt="image-20250615192203646" style="zoom: 33%;" />

##### **5.2.3.7 算符优先文法的最左素短语**

<img src="./assets/image-20250615192252708.png" alt="image-20250615192252708" style="zoom: 33%;" />

<img src="./assets/image-20250615192308970.png" alt="image-20250615192308970" style="zoom: 33%;" />

<img src="./assets/image-20250615192955459.png" alt="image-20250615192955459" style="zoom:33%;" />

<img src="./assets/image-20250615192342071.png" alt="image-20250615192342071" style="zoom: 33%;" />

##### **5.2.3.8 归约步骤**

<img src="./assets/image-20250615192650520.png" alt="image-20250615192650520" style="zoom: 33%;" />

<img src="./assets/image-20250615192748445.png" alt="image-20250615192748445" style="zoom:33%;" />

<img src="./assets/image-20250615192805393.png" alt="image-20250615192805393" style="zoom:50%;" />

==**😢缺点：**==容易误判

<img src="./assets/image-20250615193022420.png" alt="image-20250615193022420" style="zoom:33%;" />

##### 5.2.3.9 优先函数

**1、概述**

​	在实际实现算符优先分析算法时，考虑到存储开销，一般不采用优先表，而是采用优先函数。

​	优先函数是优先表的线性化。

<img src="./assets/image-20250626153259368.png" alt="image-20250626153259368" style="zoom:50%;" />

**2、特点<font color='red'>（考点）</font>**

- 便于比较，**<font color='blue'>节省空间</font>**；
- **<font color='blue'>原来不存在优先关系的两个终结符</font>**，由于与自然数相对应，**<font color='blue'>变成可以比较的</font>。**要进行一些特殊的判断。
- **<font color='blue'>优先函数不唯一</font>**，只要存在一对，必存在无穷对优先函数。
- 有许多优先关系表不存在优先函数

<img src="./assets/image-20250626153822594.png" alt="image-20250626153822594" style="zoom:50%;" />

**3、构造方法**

<img src="./assets/image-20250626154059869.png" alt="image-20250626154059869" style="zoom:50%;" />

==**🌰例子 **==

优先函数为：

<img src="./assets/image-20250626154243692.png" alt="image-20250626154243692" style="zoom: 67%;" />

<img src="./assets/image-20250626154257821.png" alt="image-20250626154257821" style="zoom: 80%;" /><img src="./assets/image-20250626154308821.png" alt="image-20250626154308821" style="zoom: 80%;" />

<img src="./assets/image-20250626154439458.png" alt="image-20250626154439458" style="zoom:50%;" /><img src="./assets/image-20250626154459444.png" alt="image-20250626154459444" style="zoom:50%;" />



### 5.3 规范规约

==**🌟规范归约的基本问题**==

- 如何找出或确定<font color='blue'>**可归约串**</font>——**<font color='blue'>句柄</font>**？
- 对找出的**<font color='blue'>可归约串</font>**——**<font color='blue'>句柄替换为哪一个非终结符号</font>**？

#### 5.3.1 短语、直接短语、句柄

<img src="./assets/image-20250615193125965.png" alt="image-20250615193125965" style="zoom: 33%;" />

<img src="./assets/image-20250615193207503.png" alt="image-20250615193207503" style="zoom: 33%;" />

<img src="./assets/image-20250615193235403.png" alt="image-20250615193235403" style="zoom: 50%;" />

<img src="./assets/image-20250615193253670.png" alt="image-20250615193253670" style="zoom:50%;" />

==🌟**二义性文法的语法树可能不唯一，导致对应的句柄可能不唯一**==

<img src="./assets/image-20250615193315629.png" alt="image-20250615193315629" style="zoom:33%;" />

#### 5.3.2 规范归约

<img src="./assets/image-20250615193502619.png" alt="image-20250615193502619" style="zoom: 33%;" />

<img src="./assets/image-20250615193520464.png" alt="image-20250615193520464" style="zoom: 50%;" />

<img src="./assets/image-20250615193553811.png" alt="image-20250615193553811" style="zoom:50%;" />

<img src="./assets/image-20250615193619155.png" alt="image-20250615193619155" style="zoom:50%;" />

<img src="./assets/image-20250615193648140.png" alt="image-20250615193648140" style="zoom: 50%;" />

### 5.4 LR分析方法

#### 5.4.1 概念

<img src="./assets/image-20250615193850907.png" alt="image-20250615193850907" style="zoom: 33%;" />

<img src="./assets/image-20250616123159741.png" alt="image-20250616123159741" style="zoom: 40%;" />

#### 5.4.2 LR分析法原理

<img src="./assets/image-20250616123521485.png" alt="image-20250616123521485" style="zoom:35%;" />

<img src="./assets/image-20250616123712869.png" alt="image-20250616123712869" style="zoom:45%;" />

#### 5.4.3 活前缀

**1、活前缀**

<img src="./assets/image-20250616123917664.png" alt="image-20250616123917664" style="zoom: 45%;" />

==**📑题目：**==

对于某文法规范句型 aBcDef，如果句柄是 Bc，下面哪个字符串是活前缀（**<font color='blue'>C</font>**）

(A) B  (B) Bc (C) aB (D) aBcD

<img src="./assets/image-20250616124237695.png" alt="image-20250616124237695" style="zoom: 33%;" />

**2、有效项目集**

<img src="./assets/image-20250616125110225.png" alt="image-20250616125110225" style="zoom:50%;" />

**3、活前缀的现实意义**

<img src="./assets/image-20250616125311773.png" alt="image-20250616125311773" style="zoom:50%;" />

#### 5.4.4 LR(0)项目

<img src="./assets/image-20250616124438583.png" alt="image-20250616124438583" style="zoom: 33%;" />

#### 5.4.5 拓广文法

<img src="./assets/image-20250616124608303.png" alt="image-20250616124608303" style="zoom:50%;" />

<img src="./assets/image-20250616124645630.png" alt="image-20250616124645630" style="zoom:50%;" />

#### 5.4.6 识别活前缀的方法

##### 5.4.6.1 NFA方法

**STEP1 构建NFA**

<img src="./assets/image-20250616124809769.png" alt="image-20250616124809769" style="zoom:50%;" />

<img src="./assets/image-20250616124857686.png" alt="image-20250616124857686" style="zoom:50%;" />

**STEP2 把NFA转成DFA**

<img src="./assets/image-20250616124925959.png" alt="image-20250616124925959" style="zoom:50%;" />

==**🌟项目集I的闭包CLOSURE(I)的计算方法**==

<img src="./assets/image-20250616125422344.png" alt="image-20250616125422344" style="zoom:50%;" />

##### 5.4.6.2 LR(0)项目集规范族

<img src="./assets/image-20250616125822142.png" alt="image-20250616125822142" style="zoom:50%;" />

**STEP1 构建状态转换函数GO(I,X)**

<img src="./assets/image-20250616125927273.png" alt="image-20250616125927273" style="zoom:50%;" />

<img src="./assets/image-20250616130007186.png" alt="image-20250616130007186" style="zoom:50%;" />

**STEP2 LR(0)项目集规范族构造算法**

<img src="./assets/image-20250616130059619.png" alt="image-20250616130059619" style="zoom:50%;" />

<img src="./assets/image-20250616130119084.png" alt="image-20250616130119084" style="zoom:50%;" />

<img src="./assets/image-20250616130217228.png" alt="image-20250616130217228" style="zoom:50%;" />

==**🤔如何一步就构造出项目集I的闭包CLOSURE(I)?**==

​	初始态是所有的产生式且·在最开始的地方。然后从该状态出发，依次尝试吃每一种终结符。

​	在吃每一种终结符时，对于可以移动·的产生式进行保留，并且判断移动完后该·后面是否为非终结符？如果是的话，则把以该非终结符为产生式左侧且·在起点的LR(0)项目添加进该闭包。

#### 5.4.7 分析表

<img src="./assets/image-20250616130410911.png" alt="image-20250616130410911" style="zoom:50%;" />

**1、ACTION[s,a]**

<img src="./assets/image-20250616130437664.png" alt="image-20250616130437664" style="zoom:50%;" />

**2、ACTION和GOTO子表的构造方法**

**STEP1 构造LR(0)分析表**

<img src="./assets/image-20250616130550751.png" alt="image-20250616130550751" style="zoom:50%;" />

**STEP2 基于LR(0)分析表构造ACTION和GOTO子表**

<img src="./assets/image-20250616130634803.png" alt="image-20250616130634803" style="zoom:50%;" />

![image-20250616133325141](./assets/image-20250616133325141.png)

#### 5.4.8 分析过程

==🌟对于归约操作，需要找到对应的产生式，例如：A->$\alpha_{1}$$\alpha_{2}$$\alpha_{3}$...$\alpha_{r}$，产生式右侧长度为r。==

**STEP1** 需要弹出符号栈顶部的r个符号，弹出状态栈顶部的r个状态，根据当前状态栈顶部的编号定位分析表的行。

**STEP2** 根据产生式左侧的非终结符定位到GOTO表中的列。

**STEP3** 得到对应的状态，压入状态栈中。

<img src="./assets/image-20250616133452436.png" alt="image-20250616133452436" style="zoom:50%;" />

<img src="./assets/image-20250616133506254.png" alt="image-20250616133506254" style="zoom:50%;" />

#### 5.4.9 LR文法

<img src="./assets/image-20250616134452459.png" alt="image-20250616134452459" style="zoom:50%;" />

##### 5.4.9.1 LR(0)文法

<img src="./assets/image-20250616134625866.png" alt="image-20250616134625866" style="zoom:50%;" />

##### 5.4.9.2 SLR(1)分析表的构造

**1、SLR(1)**

只有当一个文法G是LR(0)文法，才能构造出LR(0)分析表。

对于LR(0)规范族中冲突的项目集（状态）用**<font color='blue'>向前查看一个符号</font>**的办法进行处理，以解决冲突。即**<font color='blue'>利用上下文信息来消除当前的歧义</font>**。

**SLR(1)（简单的LR(1)分析法）：**对有冲突的状态才向前查看一个符号，以确定做哪种动作。

==**🌟·不到产生式右侧的最末端时，一定要后面跟的是终结符才会是移进操作 **==

<img src="./assets/image-20250616134925492.png" alt="image-20250616134925492" style="zoom:50%;" />

<img src="./assets/image-20250616135311529.png" alt="image-20250616135311529" style="zoom:50%;" />



**2、SLR(1)文法**

<img src="./assets/image-20250616135439330.png" alt="image-20250616135439330" style="zoom:50%;" />

**归约操作** A->$\alpha$·➡️求FOLLOW(A)（也就是产生式左侧的非终结符的FOLLOW集）

**移进操作** X->$\alpha$·$b\beta$➡️{b}（也就是·之后的终结符）

**3、SLR(1)分析表的构造**

<img src="./assets/image-20250616140547313.png" alt="image-20250616140547313" style="zoom:50%;" />

<img src="./assets/image-20250616140607423.png" alt="image-20250616140607423" style="zoom:50%;" />

<img src="./assets/image-20250616140628418.png" alt="image-20250616140628418" style="zoom:50%;" />

<img src="./assets/image-20250616140702098.png" alt="image-20250616140702098" style="zoom:50%;" />

<img src="./assets/image-20250616140753830.png" alt="image-20250616140753830" style="zoom:50%;" />

**4、SLR(1)方法**

🌟基于原本的**<font color='blue'>LR(0)分析表/LR(0)项目集</font>**，找到**<font color='blue'>移进-归约冲突</font>**和**<font color='blue'>归约-归约</font>**冲突。检查他们是否可以通过SLR(1)方法来解决冲突。

<img src="./assets/image-20250616141114490.png" alt="image-20250616141114490" style="zoom:50%;" />

<img src="./assets/image-20250616141208170.png" alt="image-20250616141208170" style="zoom:45%;" />

<img src="./assets/image-20250616141149616.png" alt="image-20250616141149616" style="zoom:45%;" />

<img src="./assets/image-20250616141319323.png" alt="image-20250616141319323" style="zoom:50%;" />

##### 5.4.9.3 改进的SLR(1)分析表

**1、SLR(1)的不足**

<img src="./assets/image-20250616141947100.png" alt="image-20250616141947100" style="zoom:50%;" />

==**🤔改进方法：**==

<img src="./assets/image-20250616142026162.png" alt="image-20250616142026162" style="zoom:50%;" />

**2、改进的SLR(1)分析表的构造方法**

<img src="./assets/image-20250616142319149.png" alt="image-20250616142319149" style="zoom:50%;" />

<img src="./assets/image-20250616142337817.png" alt="image-20250616142337817" style="zoom:50%;" />

**3、SLR文法的局限性**

**（1）计算FOLLOW集合所得到的超前符号集合可能大于实际能出现的超前符号集**

<img src="./assets/image-20250616142356845.png" alt="image-20250616142356845" style="zoom: 50%;" />

<img src="./assets/image-20250616142412628.png" alt="image-20250616142412628" style="zoom:50%;" />

<img src="./assets/image-20250616142431703.png" alt="image-20250616142431703" style="zoom:50%;" />

<img src="./assets/image-20250616142458505.png" alt="image-20250616142458505" style="zoom:50%;" />

<img src="./assets/image-20250616142524373.png" alt="image-20250616142524373" style="zoom: 50%;" />

**（2）在有些情况下，归约操作不一定合适，因为栈中的活前缀不一定允许该归约操作**

<img src="./assets/image-20250616151816916.png" alt="image-20250616151816916" style="zoom:50%;" />

##### 5.4.9.4 规范LR分析

**1、LR(K)和SLR(1)的不同之处**

LR (1) 分析与 SLR (1) 解决办法比较，都是向前展望一个符号。不同之处在于：

- SLR (1) 在每个状态上给出的展望信息来源于 FOLLOW 集合

​	➡️这种展望的信息更广泛、欠精确，发生冲突的可能性也更大

- LR (1) 方法在每个状态上的展望信息都是严格地针对该状态的

​	➡️更具体、更精确，发生冲突的可能性也更小。

**2、LR(k)项目**

<img src="./assets/image-20250616152008983.png" alt="image-20250616152008983" style="zoom:50%;" />

<font color='blue'>**🌟这个只是对于归约操作进行约束，所以只对于LR(0)项目中·到产生式右边的最右侧时才有约束作用**</font>

<img src="./assets/image-20250616152113887.png" alt="image-20250616152113887" style="zoom:50%;" />

**STEP1 构造项目集I的闭包CLOSURE(I)**

<img src="./assets/image-20250616152649184.png" alt="image-20250616152649184" style="zoom:50%;" />

**STEP2 构造GO函数**

<img src="./assets/image-20250616152748626.png" alt="image-20250616152748626" style="zoom:50%;" />

**STEP3 构造LR(1)项目集族C**

<img src="./assets/image-20250616152823174.png" alt="image-20250616152823174" style="zoom: 50%;" />

**STEP4 构造LR(1)分析表**

<img src="./assets/image-20250616153051835.png" alt="image-20250616153051835" style="zoom:50%;" />

**STEP5 构造ACTION和GOTO表**

<img src="./assets/image-20250616153205752.png" alt="image-20250616153205752" style="zoom:50%;" />

由此可以得到的LR(1)项目集和转换函数

<img src="./assets/image-20250616153312940.png" alt="image-20250616153312940" style="zoom:50%;" />

**I0中的L → ·*R, =/#是由**

- S →  ·L=R,# 推出的L → ·*R, **=**   FIRST(=R#)={=}
- R →  ·L,# 推出的L → ·*R, **#**       FIRST(ε#)={#}

==**🌰再来一个例子 **==

<img src="./assets/image-20250616153330362.png" alt="image-20250616153330362" style="zoom:50%;" />

<img src="./assets/image-20250616153343612.png" alt="image-20250616153343612" style="zoom:50%;" />

<img src="./assets/image-20250616153410123.png" alt="image-20250616153410123" style="zoom:50%;" />

<img src="./assets/image-20250616153518441.png" alt="image-20250616153518441" style="zoom:50%;" />



==**📇总结 **==

LR(0)⊂SLR⊂LR(1)⊂无二义文法

<img src="./assets/image-20250616153233855.png" alt="image-20250616153233855" style="zoom:50%;" />

##### 5.4.9.5 LALR

**1、概念**

**（1）出发点**

​	规范LR分析表的状态数偏多

**（2）LALR分析表构造方法**

​	通过**<font color='blue'>合并规范LR(1)项目集</font>**来得到，即对LR自动机进行**<font color='blue'>同心状态合并</font>**

**2、特点**

（1）**LALR和SLR的分析表有同样多的状态，比规范LR分析表要小得多**

（2）LALR的能力**介于SLR和规范LR之间**

（3）LALR的能力在很多情况下已经够用

（4）合并同心状态不会引入新的**移进-归约**冲突，但可能引入新的**归约-归约**冲突

- **同心集的合并不会引起新的移进-归约冲突**

<img src="./assets/image-20250626155813242.png" alt="image-20250626155813242" style="zoom:50%;" />

- **同心集的合并有可能产生新的归约-归约冲突**

<img src="./assets/image-20250626155848334.png" alt="image-20250626155848334" style="zoom:50%;" />

（5）遇到错误时可能会执行一些多余的规约，但不会执行新的移进

**3、LALR构造**

**同心集：**项目集规范族中仅仅搜索符不一样

==**🌰例子 **==

有三组同心集，都合并

<img src="./assets/image-20250626155939139.png" alt="image-20250626155939139" style="zoom:50%;" />

==**🤔遇到错误时可能会执行一些多余的规约，但不会执行新的移进 **==

<img src="./assets/image-20250626160231309.png" alt="image-20250626160231309" style="zoom:50%;" />

<img src="./assets/image-20250626160246639.png" alt="image-20250626160246639" style="zoom:50%;" /><img src="./assets/image-20250626160257220.png" alt="image-20250626160257220" style="zoom:50%;" /><img src="./assets/image-20250626160309970.png" alt="image-20250626160309970" style="zoom:50%;" /><img src="./assets/image-20250626160319256.png" alt="image-20250626160319256" style="zoom:50%;" /><img src="./assets/image-20250626160329620.png" alt="image-20250626160329620" style="zoom:50%;" /><img src="./assets/image-20250626160341109.png" alt="image-20250626160341109" style="zoom:50%;" />

## 第六章 属性文法和语法制导翻译

​	目前实际应用中比较流行的语义描述和语义处理方法是**<font color='blue'>属性文法</font>**和**<font color='blue'>语法制导翻译</font>**的方法

### 6.1 属性文法

#### 6.1.1 属性文法

<img src="./assets/image-20250615194253945.png" alt="image-20250615194253945" style="zoom:50%;" />

#### 6.1.2 属性和语义规则

<img src="./assets/image-20250615194435511.png" alt="image-20250615194435511" style="zoom:50%;" />

#### 6.1.3 记号表示

<img src="./assets/image-20250615195637293.png" alt="image-20250615195637293" style="zoom:50%;" />

#### 6.1.4 综合属性

- 在语法树中，一个结点的**<font color='blue'>综合属性</font>**的值由其**<font color='blue'>子结点的属性值</font>**确定。

  ➡️使用**<font color='blue'>自底向上</font>**的方法在每一个结点处使用语义规则计算综合属性的值。

- **S－属性文法：**仅仅使用综合属性的属性文法。

<img src="./assets/image-20250615195842713.png" alt="image-20250615195842713" style="zoom:50%;" />

#### 6.1.5 继承属性

- 在语法树中，一个结点的**<font color='blue'>继承属性</font>**由此结点的**<font color='blue'>父结点和/或兄弟结点</font>**的某些属性确定
- 用继承属性来表示程序设计语言结构中的**<font color='blue'>上下文依赖关系</font>**很方便

==**🤔带继承属性<font color='blue'>L.in</font>的属性文法**==

<img src="./assets/image-20250615200039924.png" alt="image-20250615200039924" style="zoom: 50%;" />

<img src="./assets/image-20250615200127364.png" alt="image-20250615200127364" style="zoom:50%;" />

#### 6.1.6 总结

==**🌟注意 **==

- **产生式左边：**父亲；**产生式右边：**儿子

- **<font color='blue'>产生式右边的继承属性</font>和<font color='blue'>产生式左边的综合属性</font>是由当前产生式计算的来的。**

​	对它们都必须提供一个计算规则。属性计算规则中只能使用相应产生式中的文法符号的属性

- **<font color='blue'>产生式右边的综合属性</font>和<font color='blue'>产生式左边继承合属性</font>是不能由当前产生式计算的来的。**

  它们由其它产生式的属性规则计算或者由属性计算器的参数提供

➡️**终结符**只有**<font color='blue'>综合属性</font>**，由**<font color='blue'>词法分析器</font>**提供

➡️**非终结符**既可有**<font color='blue'>综合属性</font>**也可有**<font color='blue'>继承属性</font>**

➡️**文法开始符号**的所有**<font color='blue'>继承属性</font>**作为**<font color='blue'>属性计算前的初始值</font>**

语义规则所描述的工作可以包括**<font color='blue'>属性计算、静态语义检查、符号表操作、代码生成</font>**等等

<img src="./assets/image-20250615201028522.png" alt="image-20250615201028522" style="zoom: 50%;" />

### 6.2 基于属性文法的处理方法

<img src="./assets/image-20250615201131211.png" alt="image-20250615201131211" style="zoom:50%;" />

#### 6.2.1 依赖图

##### 6.2.1.1 构造算法

<img src="./assets/image-20250615201312874.png" alt="image-20250615201312874" style="zoom:50%;" />

<img src="./assets/image-20250615201332532.png" alt="image-20250615201332532" style="zoom:50%;" />

<img src="./assets/image-20250615201410445.png" alt="image-20250615201410445" style="zoom:50%;" />

<img src="./assets/image-20250615201456067.png" alt="image-20250615201456067" style="zoom:50%;" />

对于addtype(a,b)，就和a+b的处理方法一样，新建立一个节点addtype，然后把它作为根，连接子节点a和b

##### 6.2.1.2 计算语义规则的顺序

- 一条求值规则只有在其**<font color='blue'>各变元值均已求得</font>**的情况下才可以使用
- 如果一属性文法**<font color='blue'>不存在属性之间的循环依赖关系</font>**，那么称该文法为**<font color='blue'>良定义</font>**的
- 对于一个**<font color='blue'>有向无环</font>**的依赖图,可以通过**<font color='blue'>拓扑排序</font>**,得到**<font color='blue'>计算语义规则的顺序</font>**

<img src="./assets/image-20250615201737616.png" alt="image-20250615201737616" style="zoom:50%;" />

##### 6.2.1.3 属性计算方法——树遍历

<img src="./assets/image-20250615201955358.png" alt="image-20250615201955358" style="zoom:50%;" />

<img src="./assets/image-20250615202015998.png" alt="image-20250615202015998" style="zoom:50%;" />

==**🌰例子 **==

<img src="./assets/image-20250615202046158.png" alt="image-20250615202046158" style="zoom:50%;" />

<img src="./assets/image-20250615202107906.png" alt="image-20250615202107906" style="zoom:50%;" />

- **第一次遍历求得：**Z.h和Z.g
- **第二次遍历求得：**X.c, X.d和S.b
- **第三次遍历求得：**Y.e和Y.f

##### 6.2.1.4 一遍扫描的处理方法

<img src="./assets/image-20250615202345167.png" alt="image-20250615202345167" style="zoom: 50%;" />

### 6.3 语法制导翻译

#### 6.3.1 定义

**语法制导翻译：**在语法分析过程中，当一个产生式**<font color='blue'>获得匹配（自上而下分析）</font>**和**<font color='blue'>用于归约（自下而上分析）</font>**时，此产生式对应的语义子程序进入工作，完成既定翻译任务，产生中间代码。

- 为每个产生式配上一个**<font color='blue'>翻译子程序</font>**（称语义动作或语义子程序），并且**<font color='blue'>在语法分析的同时</font>**执行它。
- 语义动作一方面规定了产生式**<font color='blue'>产生的符号串的意义</font>**，另一方面又按照这种意义规定了**<font color='blue'>生成中间代码应做的基本动作。</font>**

<img src="./assets/image-20250615202721858.png" alt="image-20250615202721858" style="zoom:50%;" />

#### 6.3.2 作用

- 产生中间代码
- 产生目标指令
- 对输入串进行**解释执行**

#### 6.3.3 非语法制导翻译方法

与语法制导翻译方法相对的是非语法制导翻译，即翻译程序将不受输入语言的文法的控制，如形式语义学的翻译方法。

#### 6.3.4 语法制导的实现

<img src="./assets/image-20250615202957214.png" alt="image-20250615202957214" style="zoom:50%;" />

<img src="./assets/image-20250615203010703.png" alt="image-20250615203010703" style="zoom:50%;" /><img src="./assets/image-20250615203021519.png" alt="image-20250615203021519" style="zoom:50%;" />

<img src="./assets/image-20250615203040787.png" alt="image-20250615203040787" style="zoom:50%;" />

<img src="./assets/image-20250615205318091.png" alt="image-20250615205318091" style="zoom:50%;" />

## 第七章 语义分析和中间代码产生

<img src="./assets/image-20250616170318161.png" alt="image-20250616170318161" style="zoom:50%;" />

**中间语言的复杂性**：界于源语言和目标语言之间

**中间语言的好处：**

- 便于进行与机器无关的代码优化工作
- 易于移植
- 使编译程序的结构在逻辑上更为简单明确

### 7.1 中间语言

#### **7.1.1 常用的中间语言**

<img src="./assets/image-20250616184910683.png" alt="image-20250616184910683" style="zoom:50%;" />

#### 7.1.2 后缀式<font color='red'>（考点）</font>

**1、概念**

<img src="./assets/image-20250616185031889.png" alt="image-20250616185031889" style="zoom:50%;" />

**<font color='blue'>逆波兰表示法不用括号。</font>**只要**<font color='blue'>知道每个算符的目数</font>**，对于后缀式，不论从哪一端进行扫描，**<font color='blue'>都能对它进行唯一分解</font>**。

**2、计算**

==**🤔后缀式的计算：**==

- 用一个**<font color='blue'>栈</font>**实现。
- **计算过程：**
  - 自左至右扫描后缀式，每碰到运算量就把它推进栈。
  - 每碰到k目运算符就把它作用于栈顶的k个项，**<font color='blue'>并用运算结果代替这k个项</font>**。
  - <font color='blue'>**当前分析的运算符若优先级小于栈顶的运算符，则入栈；否则弹出栈顶的运算符，并再次判断优先级。**</font>

==**🌟常见的运算符优先级：**==

not（$\neg$）> and（$\and$）> or（$\or$）

对于括号，(优先级最低，而)优先级最高。但在逆波兰表示中不需要有括号。

==**📑题目：**==

表达式(┐A∨B)∧(C∨D)的逆波兰表示为：A┐B∨CD∨∧

==**🌰例子：**==

<img src="./assets/image-20250616190636117.png" alt="image-20250616190636117" style="zoom:50%;" />

**3、把表达式翻译成后缀式的语义规则描述**

<img src="./assets/image-20250616190530655.png" alt="image-20250616190530655" style="zoom:50%;" />

<img src="./assets/image-20250616190549969.png" alt="image-20250616190549969" style="zoom:50%;" />

#### 7.1.3 图表示法

**==🌰例子：==** 产生赋值语句抽象语法树的属性文法

<img src="./assets/image-20250616191310732.png" alt="image-20250616191310732" style="zoom:50%;" />

**a:=b\*(-c)+b\*(-c)的图表示法**

<img src="./assets/image-20250616191339572.png" alt="image-20250616191339572" style="zoom:50%;" />

##### 7.1.3.1 抽象语法树

**1、概念**

<img src="./assets/image-20250616190909719.png" alt="image-20250616190909719" style="zoom:50%;" />

**2、建立表达式的抽象语法树**

<img src="./assets/image-20250616191025641.png" alt="image-20250616191025641" style="zoom: 50%;" />

**3、建立抽象语法树的语义规则**

<img src="./assets/image-20250616191113380.png" alt="image-20250616191113380" style="zoom:50%;" />

==**🌰例子：**== a-4+c的抽象语法树

<img src="./assets/image-20250616191149422.png" alt="image-20250616191149422" style="zoom:50%;" />

##### 7.1.3.2 DAG（有向无循环图）

<img src="./assets/image-20250616191538293.png" alt="image-20250616191538293" style="zoom:50%;" />

==**🌰例子：**== a+a\*(b-c)+(b-c)\*d的图表示法

<img src="./assets/image-20250616191837789.png" alt="image-20250616191837789" style="zoom: 33%;" />

##### 7.1.3.3 三地址代码

**1、定义**

三地址代码可以看成是抽象语法树或DAG的一种**<font color='blue'>线性表示</font>**

形如 X:=y op z

==**🌰例子：**== a:=b\*(-c)+b\*(-c)的图表示法

<img src="./assets/image-20250616192023772.png" alt="image-20250616192023772" style="zoom:50%;" />

**2、三地址语句的种类**

<img src="./assets/image-20250616192112228.png" alt="image-20250616192112228" style="zoom:50%;" />

**3、语句的三地址代码**

<img src="./assets/image-20250616192328706.png" alt="image-20250616192328706" style="zoom:50%;" />

**4、赋值语句的文法**

<img src="./assets/image-20250616192911276.png" alt="image-20250616192911276" style="zoom:50%;" />

==**🌰例子：**==

<img src="./assets/image-20250616193009670.png" alt="image-20250616193009670" style="zoom:50%;" />

**a:=b\*(-c)+b\*(-c)三地址语句翻译**

<img src="./assets/image-20250616193043779.png" alt="image-20250616193043779" style="zoom:50%;" />

**5、三地址语句**<font color='red'>**（考点）**</font>

**（1）四元式**

<img src="./assets/image-20250616193229577.png" alt="image-20250616193229577" style="zoom: 50%;" />

**（2）三元式**

<img src="./assets/image-20250616193321928.png" alt="image-20250616193321928" style="zoom:50%;" />

**（3）间接三元式**

<img src="./assets/image-20250616193500303.png" alt="image-20250616193500303" style="zoom:50%;" />

<img src="./assets/image-20250616193523743.png" alt="image-20250616193523743" style="zoom:50%;" />

**（4）总结**

- 三元式中使用了指向三元式的指针，**<font color='blue'>优化时修改较难</font>**。
- 间接三元式优化**<font color='blue'>只需要更改间接码表，并节省三元式表存储空间</font>**。
- 四元式表**<font color='blue'>修改较容易</font>**，只是临时变量要填入符号表，**<font color='blue'>占据一定存储空间</font>**。

### 7.2 说明语句的翻译

#### 7.2.1 概述

**1、**说明部分中把**定义性出现的标识符**与**类型等属性**相关联，从而确定它们在**计算机内部的表示法、取值范围**及**可对其进行的运算**。

**2、为了产生有效地可执行目标代码，对于说明部分的翻译，需要：**

- 把与标识符相关联的类型等属性填入符号表中
- 考虑到标识符所标记的对象的存储分配问题

#### 7.2.2 常量定义的翻译

<img src="./assets/image-20250616194723538.png" alt="image-20250616194723538" style="zoom:50%;" />

<img src="./assets/image-20250616194821849.png" alt="image-20250616194821849" style="zoom:50%;" />

#### 7.2.3 变量说明的翻译

**1、概念**

<img src="./assets/image-20250616194901990.png" alt="image-20250616194901990" style="zoom:50%;" />

<img src="./assets/image-20250616194919783.png" alt="image-20250616194919783" style="zoom:50%;" />

**2、文法转换**

==**🌟文法转换（引入辅助非终结符）**==

<img src="./assets/image-20250616194958212.png" alt="image-20250616194958212" style="zoom:50%;" />

**3、保留作用域信息**

<img src="./assets/image-20250616195023825.png" alt="image-20250616195023825" style="zoom:50%;" />

**4、语义规则中的操作**

<img src="./assets/image-20250616195156963.png" alt="image-20250616195156963" style="zoom:50%;" />

<img src="./assets/image-20250616195210380.png" alt="image-20250616195210380" style="zoom:50%;" />

<img src="./assets/image-20250616195336555.png" alt="image-20250616195336555" style="zoom:50%;" />

### 7.3 赋值语句的翻译

#### 7.3.1 两遍扫描翻译的属性文法

<img src="./assets/image-20250618132953499.png" alt="image-20250618132953499" style="zoom:50%;" />

#### 7.3.2 一遍扫描翻译

##### 7.3.2.1 简单算术表达式及赋值语句

<img src="./assets/image-20250618133141167.png" alt="image-20250618133141167" style="zoom:50%;" />

<img src="./assets/image-20250618133231262.png" alt="image-20250618133231262" style="zoom:50%;" />

<img src="./assets/image-20250618133337737.png" alt="image-20250618133337737" style="zoom:50%;" />

==**🌰a:=b\*(-c)+b\*(-c)一遍翻译 **==

<img src="./assets/image-20250618133430335.png" alt="image-20250618133430335" style="zoom:50%;" />

##### 7.3.2.2 类型转换

<img src="./assets/image-20250618133635899.png" alt="image-20250618133635899" style="zoom:50%;" />

==**🌰产生式 E→E1＋E2 的语义动作 **==

<img src="./assets/image-20250618134045241.png" alt="image-20250618134045241" style="zoom: 67%;" />

### 7.4 布尔表达式的翻译

#### 7.4.1 布尔表达式的翻译

<img src="./assets/image-20250618134323160.png" alt="image-20250618134323160" style="zoom:50%;" />

==**🌟运算符优先级 **==**<font color='red'>（考点）</font>**

- **布尔运算 < 关系运算**
- **关系运算符：**同级
- **布尔运算符（从高到低）：**not, and, or（同级左结合）

#### 7.4.2 数值表示法

##### 7.4.2.1 计算方式

<img src="./assets/image-20250618134700772.png" alt="image-20250618134700772" style="zoom:50%;" />

<img src="./assets/image-20250618134803886.png" alt="image-20250618134803886" style="zoom:50%;" />

##### 7.4.2.2 翻译模式

<img src="./assets/image-20250618134938427.png" alt="image-20250618134938427" style="zoom:50%;" />

<img src="./assets/image-20250618134953205.png" alt="image-20250618134953205" style="zoom:50%;" />

==**🌰例子 **==

<img src="./assets/image-20250618135019430.png" alt="image-20250618135019430" style="zoom:50%;" />

<img src="./assets/image-20250618135058118.png" alt="image-20250618135058118" style="zoom:50%;" />

### 7.5 两遍扫描条件控制及其语句的翻译

<img src="./assets/image-20250618141652647.png" alt="image-20250618141652647" style="zoom:50%;" />

#### 7.5.1 作为条件控制的布尔式翻译

##### 7.5.1.1 概述

<img src="./assets/image-20250618141624429.png" alt="image-20250618141624429" style="zoom:50%;" />

<img src="./assets/image-20250618141715483.png" alt="image-20250618141715483" style="zoom:50%;" />

<img src="./assets/image-20250618141819137.png" alt="image-20250618141819137" style="zoom: 50%;" />

##### 7.5.1.2 $E$→$E_{1}$ or $E_{2}$

<img src="./assets/image-20250618142057199.png" alt="image-20250618142057199" style="zoom:50%;" />

##### 7.5.1.3 $E$→$E_{1}$ and $E_{2}$

<img src="./assets/image-20250618142127147.png" alt="image-20250618142127147" style="zoom:50%;" />

**7.5.1.4 $E$→ not $E_{1}$ 和 $E$→ ($E_{1}$)**

<img src="./assets/image-20250618142252828.png" alt="image-20250618142252828" style="zoom:50%;" />

##### 7.5.1.5 总结

<img src="./assets/image-20250618142355937.png" alt="image-20250618142355937" style="zoom:50%;" />

<img src="./assets/image-20250618142509536.png" alt="image-20250618142509536" style="zoom:50%;" />

==**🌰a<b or c<d and e<f **==

![image-20250618142544313](./assets/image-20250618142544313.png)

#### 7.5.2 控制语句的翻译

<img src="./assets/image-20250618142736801.png" alt="image-20250618142736801" style="zoom:50%;" />

##### 7.5.2.1 if-then语句的属性文法

<img src="./assets/image-20250618142904323.png" alt="image-20250618142904323" style="zoom:50%;" />

##### 7.5.2.2 if-then-else语句的属性文法

<img src="./assets/image-20250618143043440.png" alt="image-20250618143043440" style="zoom:50%;" />

==**🌰例子 **==

<img src="./assets/image-20250618143124267.png" alt="image-20250618143124267" style="zoom:50%;" />

##### 7.5.2.3 while-do语句的属性文法

<img src="./assets/image-20250618143537769.png" alt="image-20250618143537769" style="zoom:50%;" />

==**🌰例子 **==

<img src="./assets/image-20250618143548917.png" alt="image-20250618143548917" style="zoom:50%;" />

### 7.6 一遍扫描条件控制及其语句的翻译<font color='red'>（考点）</font>

#### 7.6.1 布尔表达式的翻译

<img src="./assets/image-20250618144106578.png" alt="image-20250618144106578" style="zoom:50%;" />

##### 7.6.1.1 回填

**1、出发点**

**😢问题：**一遍扫描的时候还没有语法树，信息不全

​		➡️四元式转移地址无法立即知道

**😎方法：**把这个未完成的四元式地址作为E的语义值保存，待机"回填"

**2、实现**

为非终结符E设置两个综合属性**（记录布尔表达式E所对应的四元式中需回填）**：

- **E.truelist：**“真”出口的四元式的标号所构成的链表
- **E.falselist：**”假“出口的四元式的标号所构成的链表

==**🌰例子 **==

​	假定E的四元式中需要回填"真"出口的p，q，r三个四元式，则E.truelist 为下列链:

<img src="./assets/image-20250618144436268.png" alt="image-20250618144436268" style="zoom:50%;" />

**3、翻译模式**

<img src="./assets/image-20250618145445204.png" alt="image-20250618145445204" style="zoom:50%;" />

<img src="./assets/image-20250618145622014.png" alt="image-20250618145622014" style="zoom:50%;" />

##### 7.6.1.2  $E$→$E_{1}$ or $ME_{2}$

<img src="./assets/image-20250618145810033.png" alt="image-20250618145810033" style="zoom:50%;" />

##### **7.6.1.3  $E$→$E_{1}$ and $ME_{2}$**

<img src="./assets/image-20250618145921799.png" alt="image-20250618145921799" style="zoom:50%;" />

##### **7.6.1.4 $E$→ not $E_{1}$ 和 $E$→ ($E_{1}$)**

<img src="./assets/image-20250618145954698.png" alt="image-20250618145954698" style="zoom:50%;" />

==**🌰 a<b or c<d and e<f **==

<img src="./assets/image-20250618150107164.png" alt="image-20250618150107164" style="zoom:50%;" />

<img src="./assets/image-20250618152104219.png" alt="image-20250618152104219" style="zoom:50%;" />

<img src="./assets/image-20250618150234175.png" alt="image-20250618150234175" style="zoom:100%;" />

#### 7.6.2 控制流语句的翻译

<img src="./assets/image-20250618152335735.png" alt="image-20250618152335735" style="zoom:50%;" />

##### 7.6.2.1 if语句的翻译

<img src="./assets/image-20250618152509839.png" alt="image-20250618152509839" style="zoom:50%;" />

<img src="./assets/image-20250618152527365.png" alt="image-20250618152527365" style="zoom:50%;" />

==**🌰例子 **==

<img src="./assets/image-20250618152549229.png" alt="image-20250618152549229" style="zoom:50%;" />

<img src="./assets/image-20250618162915831.png" alt="image-20250618162915831" style="zoom: 40%;" />

##### 7.6.2.2 while语句的翻译

<img src="./assets/image-20250618154647214.png" alt="image-20250618154647214" style="zoom:50%;" />

<img src="./assets/image-20250618154703306.png" alt="image-20250618154703306" style="zoom:50%;" />

##### 7.6.2.3 其他语句的翻译

**1、L → L;S**

<img src="./assets/image-20250618154835045.png" alt="image-20250618154835045" style="zoom:50%;" />

**2、其他**

<img src="./assets/image-20250618154907405.png" alt="image-20250618154907405" style="zoom:50%;" />

==**🌰例子 **==

**🌟这里要不要写107和回填101取决于你考试的时候卷子上给出的语义规则！如果没有S→L;MS和M→ε，那么就不用！**

<img src="./assets/image-20250618154950438.png" alt="image-20250618154950438" style="zoom:50%;" />

<img src="./assets/image-20250628121928556.png" alt="image-20250628121928556" style="zoom:33%;" />

#### 7.6.3 标号与goto语句

**1、标号与goto语句**

<img src="./assets/image-20250618163127979.png" alt="image-20250618163127979" style="zoom:50%;" />

**2、符号表信息**

<img src="./assets/image-20250618163227884.png" alt="image-20250618163227884" style="zoom:50%;" />

**3、语义动作**

<img src="./assets/image-20250618163243737.png" alt="image-20250618163243737" style="zoom:50%;" />

<img src="./assets/image-20250618163336261.png" alt="image-20250618163336261" style="zoom:50%;" />

### 7.7 过程调用的处理

<img src="./assets/image-20250618163418733.png" alt="image-20250618163418733" style="zoom:50%;" />

#### 7.7.1 过程调用的文法

<img src="./assets/image-20250618163806747.png" alt="image-20250618163806747" style="zoom:50%;" />

#### 7.7.2 过程调用的翻译

<img src="./assets/image-20250618163841632.png" alt="image-20250618163841632" style="zoom:50%;" />

<img src="./assets/image-20250618163858549.png" alt="image-20250618163858549" style="zoom:50%;" />

## 第八章 符号表

### 8.1 符号表的组织与作用

#### 8.1.1 符号表的作用

**1、符号表的概念**

（1）名字（标识符）

（2）此名字相关的有关信息

- **种属：**简单变量、数组、过程等
- **类型：**整、实、布尔等

==**🤔用途：**==用于语义检查、产生中间代码、生成目标代码等不同阶段

<img src="./assets/image-20250624101443686.png" alt="image-20250624101443686" style="zoom:50%;" />

==**📑题目：**==符号表由词法分析程序建立，由语法分析程序使用。**（<font color='red'>X</font>）**

​	符号表通常由词法分析程序开始建立，在编译的各个阶段（包括语法分析、语义分析、中间代码生成、代码优化和目标代码生成等阶段）都可能对其进行创建、查询、更新等操作，并非仅由语法分析程序使用。

==**🌰编译过程的主要符号表：**==符号名表、二元式表、常数表、入口名表、标号表、四元式表等

**2、符号表的构成**

<img src="./assets/image-20250622165158246.png" alt="image-20250622165158246" style="zoom:50%;" />

- 每一 <font color='blue'>**项/入口**</font> 包含两大 **<font color='blue'>栏/区段/字域</font>**：名字栏和信息栏
  - **名字栏：**也称主栏。主栏的内容称为关键字。
  - **信息栏：**包含许多子栏和标志位，用来记录相应名字的种种不同属性。

==**🌟查填符号表一般是通过匹配名字来实现的 **==

​	符号表中表项是关于名字的说明，因名字用途不同表项格式不一定统一，可用记录表示表项，为统一记录格式可设指针指向表外存放的其他信息。

**3、对符号表的操作**
（1）根据名字查找一个项；
（2）新增一项；
（3）根据名字更新一项中的某些信息；
（4）根据名字访问一项中的某些信息；
（5）根据名字删除一项。

#### 8.1.2 符号表的组织方式

**1、直接方式**

​	各栏长度固定, 内容直接填入

- **优点：**易于组织、填写和查找
- **缺点：**浪费空间

**2、间接方式**

​	内容填入其他数据结构中，符号表栏中仅放置指示器，指向该位置

==**🌰名字栏的间接组织方式 **==

<img src="./assets/image-20250624101812998.png" alt="image-20250624101812998" style="zoom:50%;" />

==**🌰信息栏的间接组织方式 **==

<img src="./assets/image-20250624101826762.png" alt="image-20250624101826762" style="zoom:50%;" />

#### 8.1.3 符号表的存储	

​	一张可容纳 N 项的符号表在存储器中可用下述两种不同方式表示（假定每项需用 K 个字）：
**（1）连续存储（水平划分）**

​	把每一项置于连续的 K 个存储单元中，从而给出一张 K*N 个字的表。

<img src="./assets/image-20250624102000459.png" alt="image-20250624102000459" style="zoom:50%;" />

**（2）子表存放（垂直划分）**

​	把整个符号表分成m个子表，如T1,T2,…Tm，每个子表含有N项.

​	第i项的全部内容是T1[i]…Tm[i]的并

<img src="./assets/image-20250624102114995.png" alt="image-20250624102114995" style="zoom:50%;" />

==**🤔哪一种划分更好？ **==垂直划分

为了**<font color='blue'>合理使用存储空间</font>**（特别是重新利用那些已经过时的信息栏所占用的空间）

➡️以便靠后的子表在不同阶段可以重新安排

==**🌰例子 **==

主栏和信息栏分成两个字表，主栏占两个字，信息栏占四个字。

<img src="./assets/image-20250622171009214.png" alt="image-20250622171009214" style="zoom:50%;" />

==🌟不同种属名字的相应信息往往不同，信息栏的长度也不同==

➡️<font color='blue'>**按不同种属建立不同的符号表**</font>常常比较方便

### 8.2 整理与查找

#### 8.2.1 线性查找

1. **构造：**按关键字出现的顺序填写各个项。
2. **查找：**顺序查找。
3. **特点：**构造方法简单，查找效率不高。

<img src="./assets/image-20250622171223091.png" alt="image-20250622171223091" style="zoom: 67%;" />

#### 8.2.2 二叉树

1. **构造：**按关键字 “值” 的 “大小顺序” 填写各个项。为提高构造过程填表的效率，可将符号表组织成一棵二叉树。
2. **查找：**对折法（对半查找）。

<img src="./assets/image-20250622171402397.png" alt="image-20250622171402397" style="zoom: 67%;" />

3. **特点：**构造过程比较复杂，实现上略为困难一些，查找效率高。

<img src="./assets/image-20250622171343181.png" alt="image-20250622171343181" style="zoom: 67%;" /><img src="./assets/image-20250622171330957.png" alt="image-20250622171330957" style="zoom:60%;" />

#### 8.2.3 杂凑技术

1. **构造：**通过地址函数 H。
2. **查找：**通过地址函数 H。
3. **特点：**杂凑表的构造和查找效率都很高，可是实现上比较复杂而且要消耗一些额外的存储空间。

<img src="./assets/image-20250622172647841.png" alt="image-20250622172647841" style="zoom:50%;" />

### 8.3 名字的作用范围

**两种程序体结构**

- **单层（并列）结构，如FORTRAN**
  - 一个FORTRAN程序由一个主程序段和若干个辅程序段组成

- **多层（嵌套）结构，如PASCAL，ADA**
  - 过程可以嵌套和递归

**1、名字的作用范围**

**作用域：**一个名字能被使用的区域范围称作这个名字的作用域。

==**🌟允许同一个标识符在不同的过程中代表不同的名字。**==

- **时间方面的含义：**名字在程序运行的**多长时间范围内**有效

  ==**🌰 C 语言中的静态变量和自动变量 **==

  - 当**静态变量**所在的函数被调用后，定义在该函数内的静态变量**并不因函数的执行完成而消失**，函数下次再被调用时还可以引用到该静态变量的上次的值，**只要主程序不退出。**

  - **自动变量**随函数的进入生效，**随函数的退出失效**

- **空间方面的含义：**指名字在程序的**多大空间范围内**有效（基于空间含义就会有局部变量和全局变量的差别）。

**2、作用域规则：最近嵌套原则**

**（1）定义**

<img src="./assets/image-20250624102226071.png" alt="image-20250624102226071" style="zoom:60%;" />	

**（2）实现最近嵌套作用域规则的办法**

==**😎法1：引入“过程编号”属性 **==

​	对每个过程指定一个唯一的编号，即过程的顺序号，以便跟踪过程里的局部名字。为了对每个过程进行编号，可以按照识别过程开头和结尾的语义规则，用**语法制导翻译的方法**实现。一个过程的编号 (层次) 作为本过程中说明的全部局部量的组成部分，即编号被看成是名字的一个组成部分。

➡️在符号表中表示局部名字用一个二元组：< 名字，过程编号 >。

➡️把整个符号表按不同的过程逻辑地划分为相应的不同段落。

​	==**🤔查找每个名字的步骤**==

​	**STEP1** 查对过程编号，确定所属的表区段落

​	**STEP2** 从此段落中查对标识符

​	==**😯匹配成功的要求：**==

- 表项中的名字其字符逐个匹配
- 该记录相关的编号和当前所处理的过程的编号匹配

​	==**🌰FORTRAN的符号表组织 **==

<img src="./assets/image-20250624102925067.png" alt="image-20250624102925067" style="zoom:50%;" />

==**😎法2：按"栈"式思想组织符号表 **==

​	查找时，从后往前查找，碰到的第一个名字就是所需查找的名字

​	==**🌰Pascal的符号表组织 **==

<img src="./assets/image-20250624102958806.png" alt="image-20250624102958806" style="zoom:50%;" />

<img src="./assets/image-20250624103014340.png" alt="image-20250624103014340" style="zoom:50%;" />

## 第九章 运行时存储空间组织

### 9.1 目标程序运行时的活动

#### 9.3.1 过程的活动

<img src="./assets/image-20250618164621065.png" alt="image-20250618164621065" style="zoom:50%;" />

==**🌰例子 **==

<img src="./assets/image-20250618164636506.png" alt="image-20250618164636506" style="zoom:50%;" />

<img src="./assets/image-20250618164652037.png" alt="image-20250618164652037" style="zoom:50%;" />

==**🌟注意 **==

- 每次控制从过程P进入过程Q后，如果没有错误，最后都返回到过程P。
  - <font color='blue'>**对于非递归的两个过程，如果a和b都是过程的活动，那么<font color='red'>它们的生存期或者是不重叠的，或者是嵌套的</font>。**</font>
- 如果一个过程是**<font color='blue'>递归的</font>**，那么**<font color='blue'>在某一时刻可能有这个过程的几个活动活跃着</font>**。
- 编译程序组织存储空间时，要考虑激活一个过程的新活动时或从过程的活动返回时，对局部名的处理，及是否允许静态或动态存储分配等。

#### 9.3.2 过程调用

<img src="./assets/image-20250618165502572.png" alt="image-20250618165502572" style="zoom:50%;" />

#### 9.3.3 参数传递<font color='red'>（考点）</font>

<img src="./assets/image-20250618165602276.png" alt="image-20250618165602276" style="zoom:50%;" />

##### 9.3.3.1 传地址

<img src="./assets/image-20250618170132787.png" alt="image-20250618170132787" style="zoom:50%;" />

==**🌰例子 **==

<img src="./assets/image-20250618170222739.png" alt="image-20250618170222739" style="zoom:50%;" />

##### 9.3.3.2 得结果

<img src="./assets/image-20250618170337672.png" alt="image-20250618170337672" style="zoom:50%;" />

==**🌰例子 **==

<img src="./assets/image-20250618170726973.png" alt="image-20250618170726973" style="zoom:50%;" />

##### 9.3.3.3 传值

<img src="./assets/image-20250618170819071.png" alt="image-20250618170819071" style="zoom:50%;" />

==**🌰例子 **==

<img src="./assets/image-20250618170832937.png" alt="image-20250618170832937" style="zoom:50%;" />

##### 9.3.3.4 传名

<img src="./assets/image-20250618171020653.png" alt="image-20250618171020653" style="zoom:50%;" />

==**🤔如果在替换时发现过程体中的局部名和实在参数中的名字使用相同的标识符,则必须用不同标识符表示这些局部名 **==

<img src="./assets/image-20250618171109555.png" alt="image-20250618171109555" style="zoom:50%;" />

==**🌰例子 **==

<img src="./assets/image-20250618171051043.png" alt="image-20250618171051043" style="zoom:50%;" />

##### 9.3.3.5 总结

==**🌰例子 **==

<img src="./assets/image-20250618171300899.png" alt="image-20250618171300899" style="zoom:50%;" />

**传地址**

<img src="./assets/image-20250618172511228.png" alt="image-20250618172511228" style="zoom: 25%;" />

**得结果**

<img src="./assets/image-20250618172540769.png" alt="image-20250618172540769" style="zoom:25%;" />

**传值**

<img src="./assets/image-20250618172602553.png" alt="image-20250618172602553" style="zoom:25%;" />

**传名**

<img src="./assets/image-20250618172608707.png" alt="image-20250618172608707" style="zoom:25%;" />

==**📑题目 **==

<img src="./assets/image-20250618172654485.png" alt="image-20250618172654485" style="zoom: 67%;" />

**答案：C**

**传地址**

<img src="./assets/image-20250618195325270.png" alt="image-20250618195325270" style="zoom: 25%;" />

**得结果**

<img src="./assets/image-20250618195337611.png" alt="image-20250618195337611" style="zoom:25%;" />

**1、C/C++中的参数传递**

​	值传递、地址传递、引用传递、inline函数

**2、名字得作用范围**

<img src="./assets/image-20250618195542076.png" alt="image-20250618195542076" style="zoom:50%;" />

**3、作用域**

<img src="./assets/image-20250618195628812.png" alt="image-20250618195628812" style="zoom:50%;" />

<img src="./assets/image-20250618195647502.png" alt="image-20250618195647502" style="zoom:50%;" />

<img src="./assets/image-20250618195701001.png" alt="image-20250618195701001" style="zoom:50%;" />

### 9.2 运行时存储器的划分

#### 9.2.1 存储空间需求

<img src="./assets/image-20250618195823357.png" alt="image-20250618195823357" style="zoom:50%;" />

<img src="./assets/image-20250618195840061.png" alt="image-20250618195840061" style="zoom:50%;" />

#### 9.2.2 活动记录

1、**活动记录：**为了管理**<font color='blue'>一个过程活动所需的信息</font>**，使用一个==**连续的存储块**==存放这些信息，这个连续存储块称为活动记录。

2、运行时，每当进入一个过程就有一个相应的活动记录累筑于==**栈顶**==。

==🌟此记录含有**<font color='blue'>连接数据</font>**、**<font color='blue'>形式单元</font>**、<font color='blue'>**局部变量**</font>、**<font color='blue'>局部数组的内情向量</font>**和**<font color='blue'>临时工作单元</font>**等。==

**3、活动记录内容**

<img src="./assets/image-20250618200510896.png" alt="image-20250618200510896" style="zoom:50%;" />

**（1）连接数据**

- **返回数据**
- **动态链：**指向**<font color='blue'>调用该过程前的最新活动记录地址</font>**的指针
- **静态链：**指向**<font color='blue'>静态直接外层最新活动记录地址</font>**的指针，用来访问==**非局部数据**==

==**🌟静态链比动态链更加难以实现 **==

**（2）形式单元：**存放相应的**<font color='blue'>实在参数的地址或值</font>**

**（3）局部数据区：**局部变量、内情向量、临时工作单元（如存放对表达式求值的结果）

- **dx[SP]：**对任何**<font color='blue'>局部变量X</font>**的引用可表示为变址访问
- **dx：**变量X相对于活动记录起点的地址，**<font color='blue'>在编译时可确定</font>**

==**😯全局变量的访问：**==静态链

==**😯局部变量的访问：**==变址访问dx[SP]

==**📑题目：**==编译程序使用**<font color='blue'>说明标识符的过程或函数的静态层次</font>**区分标识符的作用域

#### 9.2.3 存储分配策略

🤔**静态和动态分配策略的核心区别：**在编译时能否确定数据空间的大小

<img src="./assets/image-20250618200457556.png" alt="image-20250618200457556" style="zoom:50%;" />

**1、存储分配策略分类**

- **静态分配策略**  
   - **适用条件**：编译时能够确定程序运行时所需的全部数据空间大小（如 FORTRAN 语言）。  
   - **特点**：在编译时即可安排好目标程序运行时的全部数据空间。  

- **动态分配策略**  
   - **栈式动态分配策略**  
     - **适用条件**：存储空间的动态申请与释放遵循“先请后还，后请先还”的原则，且程序名称的作用域受分程序结构限制（如 ALGOL 语言）。  
     - **特点**：通过栈结构管理内存，适用于作用域嵌套的场景。  
   - **堆式动态分配策略**  
     - **适用条件**：存储空间的动态申请与释放无固定顺序约束。  
     - **特点**：通过堆结构管理内存，适用于灵活的内存需求（如手动分配与释放）。  

**2、策略选择依据**

- **静态分配**：适用于内存需求在编译时可完全确定的语言。  
- **动态分配**：  
  - 选择**栈式**：若内存申请/释放符合“后进先出”规则且作用域明确。  
  - 选择**堆式**：若内存管理无固定模式（如任意时刻申请或释放）。  

### 9.3 静态存储分配

#### 9.3.1 FORTRAN的存储分配

<img src="./assets/image-20250618201549354.png" alt="image-20250618201549354" style="zoom:50%;" />

#### 9.3.2 存储结构

<img src="./assets/image-20250618201725082.png" alt="image-20250618201725082" style="zoom:50%;" />

#### 9.3.3 局部数据区的内容及存放次序

<img src="./assets/image-20250618202037517.png" alt="image-20250618202037517" style="zoom:50%;" />

<img src="./assets/image-20250618202051029.png" alt="image-20250618202051029" style="zoom:50%;" />

#### 9.3.4 临时变量的地址分配

<img src="./assets/image-20250618202132380.png" alt="image-20250618202132380" style="zoom:50%;" />

==**🌟只使用到两个地址，节省空间 **==

<img src="./assets/image-20250618202153033.png" alt="image-20250618202153033" style="zoom:50%;" />

### 9.4 简单的栈式存储分配

#### 9.4.1 简单程序语言（C语言为例）

<img src="./assets/image-20250619133826861.png" alt="image-20250619133826861" style="zoom:50%;" />

#### 9.4.2 存储组织

<img src="./assets/image-20250619133934905.png" alt="image-20250619133934905" style="zoom:50%;" />

**非局部数据：**<font color='blue'>**静态分配**</font>于**<font color='blue'>栈底</font>**。

**局部数据：**分配于**<font color='blue'>活动记录</font>**。

**栈式：** 每调用一个过程将其<font color='blue'>**活动记录**</font>分配于**<font color='blue'>栈顶</font>**，退出一个过程释放该空间。

<img src="./assets/image-20250619134351395.png" alt="image-20250619134351395" style="zoom:50%;" />

**dx[SP]：**对任何**<font color='blue'>局部变量</font>**X的引用可表示为变址访问

**dx：** 变量X相对于活动记录起点的地址，在编译时可确定。

#### 9.4.3 C过程调用

**1、四元式序列**

<img src="./assets/image-20250619134455620.png" alt="image-20250619134455620" style="zoom:50%;" />

**2、翻译过程**

<img src="./assets/image-20250619134542508.png" alt="image-20250619134542508" style="zoom:50%;" />

<img src="./assets/image-20250619134712243.png" alt="image-20250619134712243" style="zoom:50%;" />

<img src="./assets/image-20250619135005438.png" alt="image-20250619135005438" style="zoom: 37%;" />

### 9.5 嵌套过程语言的栈式实现

#### 9.5.1 Pascal语言

**1、概述**

<img src="./assets/image-20250619135123865.png" alt="image-20250619135123865" style="zoom:40%;" />

**2、过程调用规则**

<img src="./assets/image-20250619135335409.png" alt="image-20250619135335409" style="zoom:45%;" />

<img src="./assets/image-20250619135446138.png" alt="image-20250619135446138" style="zoom:45%;" />

==**🌰例子 **==

<img src="./assets/image-20250619135507126.png" alt="image-20250619135507126" style="zoom:50%;" />

<img src="./assets/image-20250619135630047.png" alt="image-20250619135630047" style="zoom:45%;" />

<img src="./assets/image-20250619150808374.png" alt="image-20250619150808374" style="zoom: 67%;" />

#### 9.5.2 嵌套层次显示表display<font color='red'>（考点）</font>

<img src="./assets/image-20250619151307467.png" alt="image-20250619151307467" style="zoom:50%;" />

==**📑题目：**== 过程的DISPLAY表中记录了**过程嵌套层次**。

==**🌰例子 1 **==

<img src="./assets/image-20250619151333457.png" alt="image-20250619151333457" style="zoom:50%;" />

==**🌰例子 2 **==

<img src="./assets/image-20250619151559274.png" alt="image-20250619151559274" style="zoom:50%;" />

==**🌰例子 3 **==

<img src="./assets/image-20250619151811075.png" alt="image-20250619151811075" style="zoom:50%;" />

==**🌰例子 4 **==

<img src="./assets/image-20250619162123543.png" alt="image-20250619162123543" style="zoom:50%;" />

==**🌰例子 5 **==

<img src="./assets/image-20250619162209395.png" alt="image-20250619162209395" style="zoom:50%;" />

#### 9.5.3 嵌套过程语言活动记录<font color='red'>（考点）</font>

<img src="./assets/image-20250619162415226.png" alt="image-20250619162415226" style="zoom:50%;" />

#### 9.5.4 过程调用、过程进入、过程返回

<img src="./assets/image-20250619162730272.png" alt="image-20250619162730272" style="zoom:50%;" />

<img src="./assets/image-20250619162817932.png" alt="image-20250619162817932" style="zoom:50%;" />

<img src="./assets/image-20250619162851056.png" alt="image-20250619162851056" style="zoom:50%;" />

<img src="./assets/image-20250619162906206.png" alt="image-20250619162906206" style="zoom:50%;" />

==**🌰例子 **==

**🌟作业题中的主程序有形参，可以画也可以不画**

<img src="./assets/image-20250619162531655.png" alt="image-20250619162531655" style="zoom:50%;" />

<img src="./assets/image-20250619162551287.png" alt="image-20250619162551287" style="zoom:50%;" />

<img src="./assets/image-20250619162602224.png" alt="image-20250619162602224" style="zoom:50%;" />

<img src="./assets/image-20250619162615256.png" alt="image-20250619162615256" style="zoom:50%;" />

<img src="./assets/image-20250619162625392.png" alt="image-20250619162625392" style="zoom:50%;" />

## 第十章 优化

<img src="./assets/image-20250619163755601.png" alt="image-20250619163755601" style="zoom:50%;" />

<img src="./assets/image-20250619163830394.png" alt="image-20250619163830394" style="zoom:50%;" />

### 10.1 概述

#### 10.1.1 原则

​	优化的目的是为了产生更高效的代码。由优化编译程序提供的对代码的各种变换必须遵循一定的原则：

- **等价原则：**经过优化后不应改变程序运行的结果；
- **有效原则：**使优化后所产生的目标代码运行时间较短，占用的存储空间较小；
- **合算原则：**应尽可能以较低的代价取得较好的优化效果。

#### 10.1.2 级别

- 局部优化
- 循环优化
- 全局优化

#### 10.1.3 优化的种类

- 删除多余运算(或称删除公用子表达式)
- 代码外提
- 强度消弱
- 变换循环控制条件
- 合并已知量
- 复写传播
- 删除无用赋值

==**🌰例子 **==

<img src="./assets/image-20250619210819241.png" alt="image-20250619210819241" style="zoom:50%;" />

**（0）源代码**

<img src="./assets/image-20250619210832864.png" alt="image-20250619210832864" style="zoom:50%;" />

**（1）删除公共子表达式**

<img src="./assets/image-20250619210954795.png" alt="image-20250619210954795" style="zoom:50%;" />

<img src="./assets/image-20250619211011800.png" alt="image-20250619211011800" style="zoom:50%;" />

<img src="./assets/image-20250619211111332.png" alt="image-20250619211111332" style="zoom:50%;" />

**（2）复写传播**

<img src="./assets/image-20250619211140907.png" alt="image-20250619211140907" style="zoom:50%;" />

<img src="./assets/image-20250619211200271.png" alt="image-20250619211200271" style="zoom:50%;" />

<img src="./assets/image-20250619211349934.png" alt="image-20250619211349934" style="zoom:50%;" />

<img src="./assets/image-20250619211402627.png" alt="image-20250619211402627" style="zoom:50%;" />

**（3）删除无用代码**

<img src="./assets/image-20250619211501014.png" alt="image-20250619211501014" style="zoom:50%;" />

<img src="./assets/image-20250619211513333.png" alt="image-20250619211513333" style="zoom:50%;" />

<img src="./assets/image-20250619211523683.png" alt="image-20250619211523683" style="zoom:50%;" />

**（4）强度削弱**

<img src="./assets/image-20250619211700274.png" alt="image-20250619211700274" style="zoom:50%;" />

<img src="./assets/image-20250619211713154.png" alt="image-20250619211713154" style="zoom:50%;" />

<img src="./assets/image-20250619211722639.png" alt="image-20250619211722639" style="zoom:50%;" />

**（5）删除归纳变量**

<img src="./assets/image-20250619211759663.png" alt="image-20250619211759663" style="zoom:50%;" />

<img src="./assets/image-20250619212033618.png" alt="image-20250619212033618" style="zoom:50%;" />

<img src="./assets/image-20250619212118850.png" alt="image-20250619212118850" style="zoom:50%;" />

### 10.2 局部优化

<img src="./assets/image-20250619212656502.png" alt="image-20250619212656502" style="zoom:50%;" />

#### 10.2.1 基本块

##### 10.2.1.1 基本概念

**1、基本块**

​	程序中一顺序执行语句序列，**<font color='blue'>其中只有一个入口和一个出口。</font>**

​	入口就是其中第一个语句，出口就是其中最后一个语句。

**2、如果一条三地址语句为x:=y+z，则称对x定值并引用y和z。**

**3、某个给定点是活跃的**

​	在一个基本块中的一个名字，所谓在程序中的某个给定点是活跃的，是指**<font color='blue'>如果在程序中(包括在本基本块或在其它基本块中)它的值在该点以后被引用。</font>**

##### 10.2.1.2 划分基本块

<img src="./assets/image-20250619212941194.png" alt="image-20250619212941194" style="zoom:50%;" />

<img src="./assets/image-20250619213032332.png" alt="image-20250619213032332" style="zoom:40%;" />

<img src="./assets/image-20250619213054587.png" alt="image-20250619213054587" style="zoom:40%;" />

==**🌰例子 **==

<img src="./assets/image-20250619213136625.png" alt="image-20250619213136625" style="zoom:40%;" />

<img src="./assets/image-20250619213214318.png" alt="image-20250619213214318" style="zoom:40%;" />

##### 10.2.1.3 基本块的DAG表示<font color='red'>（考点）</font>

**1、概念**

==**😎目标：**==删除公共子表达式和删除无用赋值

<img src="./assets/image-20250619213257726.png" alt="image-20250619213257726" style="zoom:50%;" />

**2、与各四元式相对应的DAG结点形式**

<img src="./assets/image-20250619213536273.png" alt="image-20250619213536273" style="zoom:50%;" />

<img src="./assets/image-20250619213436722.png" alt="image-20250619213436722" style="zoom:50%;" />

<img src="./assets/image-20250619213609433.png" alt="image-20250619213609433" style="zoom:50%;" />

<img src="./assets/image-20250619213619917.png" alt="image-20250619213619917" style="zoom:50%;" />

**3、基本块的DAG构造算法**

<img src="./assets/image-20250619213720169.png" alt="image-20250619213720169" style="zoom:50%;" />

<img src="./assets/image-20250619214555706.png" alt="image-20250619214555706" style="zoom:50%;" />

<img src="./assets/image-20250619213739767.png" alt="image-20250619213739767" style="zoom:50%;" />

<img src="./assets/image-20250619213748806.png" alt="image-20250619213748806" style="zoom:50%;" />

<img src="./assets/image-20250619213811470.png" alt="image-20250619213811470" style="zoom:50%;" />

==**🌰例子<font color='red'>（考点）</font> **==

<img src="./assets/image-20250619214642435.png" alt="image-20250619214642435" style="zoom:50%;" />

==**🌰例子<font color='red'>（考点）</font> **==

若只有A和B是出基本块之后活跃的

<img src="./assets/image-20250619214925638.png" alt="image-20250619214925638" style="zoom:50%;" />

**4、DAG的优化**

<img src="./assets/image-20250619215054656.png" alt="image-20250619215054656" style="zoom:50%;" />

##### 10.2.1.4 流图

<img src="./assets/image-20250619220308011.png" alt="image-20250619220308011" style="zoom:50%;" />

<img src="./assets/image-20250619220640686.png" alt="image-20250619220640686" style="zoom:50%;" />

### 10.3 循环优化

<img src="./assets/image-20250619220710243.png" alt="image-20250619220710243" style="zoom:50%;" />

#### 10.3.1 代码外提<font color='red'>（考点）</font>

==**🌟把循环不变运算提到循环体外 **==

<img src="./assets/image-20250619220806108.png" alt="image-20250619220806108" style="zoom:50%;" />

<img src="./assets/image-20250619221028201.png" alt="image-20250619221028201" style="zoom:50%;" />

==**🌰例子 **==

<img src="./assets/image-20250619221205407.png" alt="image-20250619221205407" style="zoom: 50%;" />

<img src="./assets/image-20250619221107179.png" alt="image-20250619221107179" style="zoom:50%;" />

**1、代码外提的条件<font color='red'>（考点）</font>**

==**🤔判断方法：**==改变后和改变前带入相同的值，是否一定会得到相同的结果？

**（1）不变运算所在的结点是L所有出口结点的必经结点**

==**😢未来可能会用到这个变量，而不是一定 **==

<img src="./assets/image-20250619221457814.png" alt="image-20250619221457814" style="zoom:50%;" />

<img src="./assets/image-20250619221619828.png" alt="image-20250619221619828" style="zoom:50%;" />

**（2）A在循环中其他地方未再定值,才能把循环不变运算A:=B op C外提**

==**😢可能会导致A的值不对 **==

<img src="./assets/image-20250619222114314.png" alt="image-20250619222114314" style="zoom:50%;" />

<img src="./assets/image-20250619222138937.png" alt="image-20250619222138937" style="zoom:50%;" />

**（3）循环中所有A的引用点都是而且仅仅是这个定值才能到达**

==**😢可能会导致走入的其他分支后，因为A的赋值被外提而在用A对其他变量赋值时出现错误 **==

<img src="./assets/image-20250619222208790.png" alt="image-20250619222208790" style="zoom:50%;" />

<img src="./assets/image-20250619222232649.png" alt="image-20250619222232649" style="zoom:50%;" />

==**😯总结 **==

- **依次查看L中各基本块的每个四元式**
  - 如果**<font color='blue'>它的每个运算对象或为常数</font>**，或**<font color='blue'>定值点在L外</font>**，则将此四元式标记为"不变运算";
- **重复第3步直至没有新的四元式被标记为"不变运算"为止;**
- **依次查看尚未被标记为“不变运算”的四元式**
  - 如果**<font color='blue'>它的每个运算对象或为常数</font>**，或**<font color='blue'>定值点在L之外</font>**，或**<font color='blue'>只有一个到达一定值点且该点上的四元式已被标记为"不变运算"</font>**，则把被查看的四元式标记为"不变运算"。

**2、代码外提算法**

<img src="./assets/image-20250619230658262.png" alt="image-20250619230658262" style="zoom:50%;" />

<img src="./assets/image-20250619231929260.png" alt="image-20250619231929260" style="zoom:50%;" />

==**🌰例子 **==

可以代码外提，虽然因为在分支中，不一定会经过，但是它再基本块之后不会再被用到（不再活跃）

<img src="./assets/image-20250619232011525.png" alt="image-20250619232011525" style="zoom:50%;" />

<img src="./assets/image-20250619232145739.png" alt="image-20250619232145739" style="zoom:50%;" />

#### 10.3.2 强度消弱

把程序中执行时间较长的运算转换为**<font color='blue'>执行时间较短的运算</font>**

如把循环中的**<font color='blue'>乘法运算</font>**用**<font color='blue'>递归加法运算</font>**替换

<img src="./assets/image-20250619232310303.png" alt="image-20250619232310303" style="zoom:50%;" />

<img src="./assets/image-20250619232348051.png" alt="image-20250619232348051" style="zoom:50%;" />

<img src="./assets/image-20250619232422779.png" alt="image-20250619232422779" style="zoom:40%;" />

#### 10.3.3 删除归纳变量

<img src="./assets/image-20250619232541603.png" alt="image-20250619232541603" style="zoom:50%;" />

==**🌟一个基本归纳变量也是一个归纳变量。**==

<img src="./assets/image-20250619233037309.png" alt="image-20250619233037309" style="zoom:50%;" />

<img src="./assets/image-20250619233105985.png" alt="image-20250619233105985" style="zoom:50%;" />

==**🌟优化算法（强度削弱和删除归纳变量的统一算法）**==

<img src="./assets/image-20250619233519157.png" alt="image-20250619233519157" style="zoom:50%;" />

## 第十一章 目标代码生成

### 11.1 基本问题

#### 11.1.1 代码生成

**1、代码生成器**

<img src="./assets/image-20250619164034770.png" alt="image-20250619164034770" style="zoom:50%;" />

**2、目标代码生成**

**（1）代码生成：**把语义分析后或优化后的**<font color='blue'>中间代码</font>**变换成**<font color='blue'>目标代码</font>**

**（2）代码生成着重考虑的问题**

- 如何使生成的目标代码较**<font color='blue'>短</font>**

- 如何充分利用计算机的**<font color='blue'>寄存器</font>**，减少目标代码中**<font color='blue'>访问存贮单元的次数</font>**

- 如何充分利用计算机的指令系统的特点

**3、基本问题**

**（1）目标代码的形式**

<img src="./assets/image-20250619164839527.png" alt="image-20250619164839527" style="zoom:50%;" />

**（2）指令选择**

- 一致性和完整性
- 指令速度和机器用语

==**🌰例子 **==

<img src="./assets/image-20250619165904824.png" alt="image-20250619165904824" style="zoom:50%;" />

**（3）寄存器分配**

<img src="./assets/image-20250619170031946.png" alt="image-20250619170031946" style="zoom:50%;" />

==**🌟最优寄存器指派是NP完全问题 **==

**（4）计算顺序选择**

### 11.2 目标机器模型

**1、考虑一个抽象的计算机模型**

- 具有多个**<font color='blue'>通用寄存器</font>**，他们既可以作为**<font color='blue'>累加器</font>**，也可以作为**<font color='blue'>变址器</font>**
- **<font color='blue'>运算</font>**必须在某个**<font color='blue'>寄存器</font>**中进行
- 含有**<font color='blue'>四种类型的指令形式</font>**

<img src="./assets/image-20250619170301678.png" alt="image-20250619170301678" style="zoom:50%;" />

<img src="./assets/image-20250619170323136.png" alt="image-20250619170323136" style="zoom:50%;" />

<img src="./assets/image-20250619170340875.png" alt="image-20250619170340875" style="zoom:50%;" />

### 11.3 一个简单的代码生成器

#### 11.3.1 引入

<img src="./assets/image-20250619170639548.png" alt="image-20250619170639548" style="zoom:40%;" />

<img src="./assets/image-20250619170654356.png" alt="image-20250619170654356" style="zoom:40%;" />

#### 11.3.2 一个简单代码生成器

<img src="./assets/image-20250619170855767.png" alt="image-20250619170855767" style="zoom:40%;" />

##### 11.3.2.1 待用信息和活跃信息

<img src="./assets/image-20250619171013747.png" alt="image-20250619171013747" style="zoom:40%;" />

**1、待用信息和活跃信息的表示**

<img src="./assets/image-20250619171415448.png" alt="image-20250619171415448" style="zoom:40%;" />

**2、待用信息和活跃信息的计算算法步骤<font color='red'>（考点）</font>**

**STEP1 初始化**

- **待用信息：**把基本块中各变量的符号表登记项中的待用信息栏填为**<font color='blue'>“非待用”</font>**
- **活跃信息：**根据**<font color='blue'>该变量在基本块出口之后是不是活跃的</font>**，把其中的活跃信息栏填为“活跃”或“非活跃”

**STEP2 更新待用信息和活跃信息**

​	从基本块出口到基本块入口**<font color='blue'>由后向前</font>**依次处理各个四元式。对每一个四元式<font color='blue'>**i: A:=B op C**</font>，依次执行下面的步骤：

==**🌟 先把旧信息填入由四元式组成的表格中，再在变量名组成的表格中进行更新 **==

1）把符号表中变量A的待用信息和活跃信息附加到四元式i上；

2）把符号表中**<font color='blue'>A</font>**的待用信息和活跃信息分别置为**<font color='blue'>“非待用”</font>**和**<font color='blue'>“非活跃”</font>**；

3）把符号表中变量B和C的待用信息和活跃信息附加到四元式i上；

4）把符号表中**<font color='blue'>B</font>**和**<font color='blue'>C</font>**的**<font color='blue'>待用信息均置为i</font>**，**<font color='blue'>活跃信息均置为“活跃”</font>**。

==**🌰例子 **==

<img src="./assets/image-20250619172239516.png" alt="image-20250619172239516" style="zoom:50%;" />

<img src="./assets/屏幕截图 2025-06-19 172402-1750325312985-2.png" alt="屏幕截图 2025-06-19 172402" style="zoom:50%;" />

==**🌰例子 **==

<img src="./assets/image-20250619200552022.png" alt="image-20250619200552022" style="zoom: 45%;" />

##### 11.3.2.2 寄存器描述和地址描述

<img src="./assets/image-20250619200730239.png" alt="image-20250619200730239" style="zoom:50%;" />

==**🌟注意 **==

- 因为寄存器的分配是局限于基本块范围之内的，一旦处理完基本块中所有四元式，**<font color='blue'>对现行值在寄存器中的每个变量，如果它在基本块之后是活跃的，则要把它存在寄存器中的值存放到它的主存单元中。</font>**
- 对形如：A:=B的四元式，**<font color='blue'>如果B的现行值在某寄存器Ri中，则无须生成目标代码</font>**，只须在RVALUE(Ri)中增加一个A，(即把Ri同时分配给B和A)，并把AVALUE(A)改为Ri。

##### 11.3.2.3 寄存器分配算法

==**📇GETREG (i: A :=B op C) 返回一个用来存放A的值的寄存器 **==

**原则1：尽可能用B独占的寄存器**

​	（1）如果B的现行值在某个寄存器Ri中，RVALUE[Ri]中只包含B

​	（2）B与A是同一个标识符

​	（3）B的现行值在执行四元式A:=B op C之后不会再引用

​	➡️选取Ri为所需要的寄存器R，并转4；

**原则2：尽可能用空闲寄存器**

​	如果有尚未分配的寄存器

​	➡️从中选取一个Ri为所需要的寄存器R，并转4；

**原则3：抢占用非空闲寄存器**

​	从已分配的寄存器中选取一个Ri为所需要的寄存器R。

​	==**😯最好使得Ri满足以下条件： **==

​	（1）占用Ri的变量的值**也同时存放在该变量的贮存单元中**

​	（2）在基本块中要**在最远的将来才会引用到或不会引用到**

**4：要不要为Ri中的变量V生成存数指令？**

**情况1：不需要生成存数指令**

（1）如果V的地址描述数组AVALUE[V]说V还保存在R之外的其他地方；

​	==**😯因为还可以从其他地方取得V **==

（2）如果V是A，且不是B或C；

​	==**😯因为V没有覆盖其他的值，而且也是最新版本的值 **==

（3）如果V不会在此之后被使用；

​	==**😯因为完全不需要V了 **==

**情况2：需要生成存数指令**

​	不满足上述情况1的所有匹配条件，则生成目标代码ST Ri，V

##### 11.3.2.4 代码生成算法<font color='red'>（考点）</font>

<img src="./assets/image-20250619201152371.png" alt="image-20250619201152371" style="zoom:45%;" />

<img src="./assets/image-20250619201212889.png" alt="image-20250619201212889" style="zoom:50%;" />

==**🌰例子 **==

<img src="./assets/image-20250619203321628.png" alt="image-20250619203321628" style="zoom:50%;" />

<img src="./assets/image-20250619203341155.png" alt="image-20250619203341155" style="zoom:50%;" />

==**🌟一定要记得写最后的ST R0, W **==

==**🌰例子 **==

设W和Y是基本块出口的活跃变量

<img src="./assets/image-20250619203354795.png" alt="image-20250619203354795" style="zoom:50%;" />

<img src="./assets/image-20250619205243515.png" alt="image-20250619205243515" style="zoom: 33%;" />
